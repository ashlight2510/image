<!DOCTYPE html>
<html lang="ko">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <title>ì´ë¯¸ì§€ í•©ì¹˜ê¸° & PDF ë³€í™˜ â€” ë¬´ë£Œ ì›¹íˆ´</title>

    <!-- SEO / OG / Canonical -->
    <meta
      name="description"
      content="ì—¬ëŸ¬ ì¥ì˜ ì´ë¯¸ì§€ë¥¼ í•œ ì¥ìœ¼ë¡œ í•©ì¹˜ê±°ë‚˜(PNG/JPG/WEBP), PDFë¡œ ë³€í™˜/ë‹¤ìš´ë¡œë“œê¹Œì§€ í•œ ë²ˆì—. ë“œë˜ê·¸ ì •ë ¬Â·ì—¬ë°±Â·ê°„ê²©Â·ë°°ì¹˜ ì§€ì›."
    />
    <meta
      name="keywords"
      content="ì´ë¯¸ì§€ í•©ì¹˜ê¸°, ì‚¬ì§„ í•©ì¹˜ê¸°, ì´ë¯¸ì§€ ë³‘í•©, png jpg webp ë³€í™˜, ì´ë¯¸ì§€ pdf ë³€í™˜, jpg pdf, png pdf, ë¬´ë£Œ ì›¹íˆ´"
    />
    <meta name="author" content="FunnyFunny Cloud" />
    <link rel="canonical" href="https://funnyfunny.cloud/" />

    <meta property="og:title" content="ì´ë¯¸ì§€ í•©ì¹˜ê¸° & PDF ë³€í™˜ â€” ë¬´ë£Œ ì›¹íˆ´" />
    <meta
      property="og:description"
      content="ì—¬ëŸ¬ ì¥ ì´ë¯¸ì§€ë¥¼ í•œ ì¥ìœ¼ë¡œ í•©ì¹˜ê³ , PDFë¡œ ë³€í™˜í•´ ë°”ë¡œ ë‹¤ìš´ë¡œë“œ!"
    />
    <!-- OG ì´ë¯¸ì§€ëŠ” ì‚¬ìš© ì„ í˜¸ì— ë§ì¶° dummyimage.com ì‚¬ìš© -->
    <meta
      property="og:image"
      content="https://dummyimage.com/1200x630/0b1220/ffffff&text=Image+Merge+%26+PDF"
    />
    <meta property="og:image:alt" content="Image Merge & PDF" />
    <meta property="og:type" content="website" />
    <meta name="twitter:card" content="summary_large_image" />

    <link
      rel="icon"
      type="image/svg+xml"
      href="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20100%20100'%3E%3Ctext%20y='0.9em'%20font-size='90'%3E%F0%9F%93%8E%3C/text%3E%3C/svg%3E"
    />

    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Drag reorder -->
    <script src="https://cdn.jsdelivr.net/npm/sortablejs@1.15.2/Sortable.min.js"></script>
    <!-- jsPDF -->
    <script src="https://cdn.jsdelivr.net/npm/jspdf@2.5.1/dist/jspdf.umd.min.js"></script>
    <!-- html2canvas for HTML to PDF conversion -->
    <script src="https://cdn.jsdelivr.net/npm/html2canvas@1.4.1/dist/html2canvas.min.js"></script>

    <style>
      :root {
        color-scheme: dark;
      }
      body {
        background: radial-gradient(
            1200px 800px at 20% 10%,
            #1b2a5a33,
            transparent 60%
          ),
          radial-gradient(1200px 800px at 90% 20%, #14532d33, transparent 55%),
          #060913;
      }
      .glass {
        background: rgba(255, 255, 255, 0.06);
        border: 1px solid rgba(255, 255, 255, 0.1);
        backdrop-filter: blur(10px);
      }
      .btn {
        display: inline-flex;
        align-items: center;
        justify-content: center;
        gap: 8px;
        border-radius: 14px;
        padding: 10px 16px;
        font-weight: 700;
        letter-spacing: -0.01em;
        transition: transform 160ms ease, box-shadow 160ms ease,
          filter 160ms ease;
        border: 1px solid transparent;
      }
      .btn:hover {
        transform: translateY(-1px);
      }
      .btn-primary {
        background: radial-gradient(
          120% 120% at 20% 20%,
          #a5f3fc 0%,
          #22d3ee 45%,
          #16a34a 100%
        );
        color: #031123;
        box-shadow: 0 10px 35px rgba(34, 211, 238, 0.25);
      }
      .btn-primary:hover {
        filter: brightness(1.03);
      }
      .btn-ghost {
        background: rgba(255, 255, 255, 0.08);
        border: 1px solid rgba(255, 255, 255, 0.18);
        color: #e5e7eb;
        box-shadow: 0 8px 26px rgba(0, 0, 0, 0.28);
      }
      .btn-ghost:hover {
        background: rgba(255, 255, 255, 0.12);
      }
      .btn-outline {
        background: transparent;
        border: 1.5px solid rgba(34, 211, 238, 0.5);
        color: #befafc;
        box-shadow: 0 0 0 1px rgba(34, 211, 238, 0.18);
      }
      .btn-sm {
        padding: 8px 12px;
        border-radius: 12px;
        font-size: 14px;
      }
      .muted {
        color: rgba(255, 255, 255, 0.75);
      }
      .chip {
        background: rgba(255, 255, 255, 0.08);
        border: 1px solid rgba(255, 255, 255, 0.14);
      }
      .ringy {
        box-shadow: 0 0 0 1px rgba(255, 255, 255, 0.1) inset;
      }
      .drop-active {
        outline: 2px dashed rgba(34, 197, 94, 0.9);
        outline-offset: 6px;
      }
      .thumb {
        aspect-ratio: 4/3;
        background: rgba(255, 255, 255, 0.05);
        border: 1px solid rgba(255, 255, 255, 0.12);
      }
      .small {
        font-size: 12px;
      }
      input[type="range"] {
        accent-color: #22c55e;
      }
    </style>
  </head>

  <body class="text-white">
    <header class="max-w-6xl mx-auto px-4 pt-8 pb-4">
      <div
        class="flex flex-col gap-3 sm:flex-row sm:items-end sm:justify-between"
      >
        <div class="flex items-center gap-3">
          <div
            class="w-11 h-11 rounded-2xl glass grid place-items-center text-2xl"
          >
            ğŸ“
          </div>
          <div>
            <h1 class="text-2xl sm:text-3xl font-extrabold tracking-tight">
              ì´ë¯¸ì§€ í•©ì¹˜ê¸° & PDF ë³€í™˜
            </h1>
            <p class="muted mt-1">
              ì—¬ëŸ¬ ì¥ ì—…ë¡œë“œ â†’ ë“œë˜ê·¸ ì •ë ¬ â†’ í•œ ì¥ìœ¼ë¡œ í•©ì¹˜ê±°ë‚˜ PDFë¡œ ì €ì¥
            </p>
          </div>
        </div>

        <!-- ë‹¤ë¥¸ ì„œë¹„ìŠ¤ ë³´ê¸°: ê¸°ë³¸ í¬í•¨ -->
        <div class="flex gap-2">
          <a
            class="btn btn-outline"
            href="https://funnyfunny.cloud/"
            target="_blank"
            rel="noopener"
            >ë‹¤ë¥¸ ì„œë¹„ìŠ¤ ë³´ê¸° â†—</a
          >
        </div>
      </div>
    </header>

    <main class="max-w-6xl mx-auto px-4 pb-14">
      <!-- HTML to PDF Section - ì£¼ìš” ê¸°ëŠ¥ìœ¼ë¡œ ìƒë‹¨ ì´ë™ -->
      <section class="glass rounded-3xl p-5 ringy mb-6">
        <div class="flex items-start justify-between gap-3">
          <div>
            <h2 class="text-lg font-bold">HTML â†’ PDF ë³€í™˜</h2>
            <p class="muted small mt-1">
              HTML íŒŒì¼ì„ ì—…ë¡œë“œí•˜ë©´ PDFë¡œ ë³€í™˜í•´ ë‹¤ìš´ë¡œë“œí•  ìˆ˜ ìˆì–´ìš”.
            </p>
          </div>
        </div>

        <div class="mt-4 grid lg:grid-cols-2 gap-4">
          <div>
            <div
              id="htmlDropzone"
              class="rounded-2xl border border-white/15 bg-white/5 p-5"
            >
              <div
                class="flex flex-col sm:flex-row sm:items-center sm:justify-between gap-3"
              >
                <div>
                  <div class="font-semibold text-white">
                    HTML íŒŒì¼ ë“œë˜ê·¸&ë“œë¡­
                  </div>
                  <div class="muted small mt-1">
                    HTMLê³¼ ì´ë¯¸ì§€ íŒŒì¼ì„ í•¨ê»˜ ì„ íƒí•˜ì„¸ìš”.
                  </div>
                </div>
                <label
                  class="btn btn-primary relative overflow-hidden cursor-pointer shadow-lg shadow-cyan-500/15"
                >
                  <input
                    id="htmlFileInput"
                    type="file"
                    class="absolute inset-0 opacity-0 cursor-pointer"
                    accept=".html,.htm,text/html,image/*"
                    multiple
                    aria-label="HTML ë° ì´ë¯¸ì§€ íŒŒì¼ ì„ íƒ"
                  />
                  <span class="font-semibold">íŒŒì¼ ì„ íƒ</span>
                </label>
              </div>
            </div>

            <div class="mt-4">
              <div class="flex items-center justify-between mb-2">
                <h3 class="font-bold">ì—…ë¡œë“œëœ HTML</h3>
                <button
                  id="btnClearHtml"
                  class="btn btn-ghost btn-sm"
                  type="button"
                  style="display: none"
                >
                  ë¹„ìš°ê¸°
                </button>
              </div>
              <div id="htmlFileName" class="muted small"></div>
            </div>

            <div class="mt-4">
              <button
                id="btnConvertHtmlToPdf"
                class="btn btn-primary w-full shadow-lg shadow-emerald-400/25"
                type="button"
                disabled
              >
                PDFë¡œ ë³€í™˜í•˜ê¸°
              </button>
              <div id="htmlStatus" class="mt-2 muted small"></div>
            </div>
          </div>

          <div>
            <div class="chip rounded-2xl p-4">
              <div class="font-semibold mb-2">ë¯¸ë¦¬ë³´ê¸°</div>
              <div
                id="htmlPreview"
                class="rounded-xl border border-white/10 bg-black/30 p-3"
                style="min-height: 300px; max-height: 600px; overflow: auto; position: relative;"
              >
                <div class="muted small text-center py-8">
                  HTML íŒŒì¼ì„ ì—…ë¡œë“œí•˜ë©´ ì—¬ê¸°ì— ë¯¸ë¦¬ë³´ê¸°ê°€ í‘œì‹œë©ë‹ˆë‹¤.
                </div>
              </div>
            </div>
          </div>
        </div>
      </section>

      <section class="grid lg:grid-cols-2 gap-4">
        <!-- Upload -->
        <div class="glass rounded-3xl p-5 ringy">
          <div class="flex items-start justify-between gap-3">
            <div>
              <h2 class="text-lg font-bold">1) ì´ë¯¸ì§€ ë„£ê¸°</h2>
              <p class="muted small mt-1">
                PNG/JPG/WEBP/GIF(ì²« í”„ë ˆì„) ë“± ë¸Œë¼ìš°ì €ê°€ ì½ëŠ” ì´ë¯¸ì§€ë¥¼
                ì§€ì›í•´ìš”.
              </p>
            </div>
            <div class="flex gap-2">
              <button id="btnClear" class="btn btn-ghost btn-sm" type="button">
                ì „ì²´ ë¹„ìš°ê¸°
              </button>
            </div>
          </div>

          <div
            id="dropzone"
            class="mt-4 rounded-2xl border border-white/15 bg-white/5 p-5"
          >
            <div
              class="flex flex-col sm:flex-row sm:items-center sm:justify-between gap-3"
            >
              <div>
                <div class="font-semibold text-white">ì—¬ê¸°ì— ë“œë˜ê·¸&ë“œë¡­</div>
                <div class="muted small mt-1">
                  ë˜ëŠ” íŒŒì¼ ì„ íƒ ë²„íŠ¼ì„ ëˆŒëŸ¬ì£¼ì„¸ìš”.
                </div>
              </div>
              <label
                class="btn btn-primary relative overflow-hidden cursor-pointer shadow-lg shadow-cyan-500/15"
              >
                <input
                  id="fileInput"
                  type="file"
                  class="absolute inset-0 opacity-0 cursor-pointer"
                  accept="image/*"
                  multiple
                  aria-label="ì´ë¯¸ì§€ íŒŒì¼ ì„ íƒ"
                />
                <span class="font-semibold">íŒŒì¼ ì„ íƒ</span>
              </label>
            </div>
            <div class="mt-3 muted small">
              ğŸ’¡ íŒ: ë¦¬ìŠ¤íŠ¸ì—ì„œ ì¸ë„¤ì¼ì„
              <span class="text-white font-semibold">ë“œë˜ê·¸</span>í•´ì„œ ìˆœì„œë¥¼
              ë°”ê¿€ ìˆ˜ ìˆì–´ìš”.
            </div>
          </div>

          <div class="mt-4">
            <div class="flex items-center justify-between">
              <h3 class="font-bold">ì—…ë¡œë“œ ëª©ë¡</h3>
              <div class="muted small"><span id="count">0</span>ì¥</div>
            </div>

            <div id="list" class="mt-3 grid sm:grid-cols-2 gap-3">
              <!-- items -->
            </div>

            <div
              id="emptyHint"
              class="mt-4 rounded-2xl border border-white/10 bg-white/5 p-4 muted small text-center"
            >
              ğŸ“· ì•„ì§ ì´ë¯¸ì§€ê°€ ì—†ì–´ìš”.<br />
              ìœ„ì—ì„œ ì—…ë¡œë“œí•˜ê±°ë‚˜ íŒŒì¼ ì„ íƒ ë²„íŠ¼ì„ ëˆŒëŸ¬ë³´ì„¸ìš”.
            </div>
          </div>
        </div>

        <!-- Options -->
        <div class="glass rounded-3xl p-5 ringy">
          <h2 class="text-lg font-bold">2) ì¶œë ¥ ì„¤ì •</h2>
          <p class="muted small mt-1">
            í•œ ì¥ ì´ë¯¸ì§€ë¡œ í•©ì¹˜ê¸°(ì„¸ë¡œ/ê°€ë¡œ/ê·¸ë¦¬ë“œ) ë˜ëŠ” PDF(í˜ì´ì§€ë³„/ê·¸ë¦¬ë“œ)ë¡œ
            ë³€í™˜.
          </p>

          <div class="mt-5 grid gap-4">
            <div class="grid sm:grid-cols-2 gap-3">
              <div class="chip rounded-2xl p-4">
                <div class="font-semibold">ì¶œë ¥ íƒ€ì…</div>
                <select
                  id="outType"
                  class="mt-2 w-full rounded-xl bg-black/30 border border-white/15 px-3 py-2"
                >
                  <option value="image">í•©ì¹œ ì´ë¯¸ì§€ë¡œ ë‹¤ìš´ë¡œë“œ</option>
                  <option value="pdf">PDFë¡œ ë‹¤ìš´ë¡œë“œ</option>
                  <option value="zip">ê°œë³„ ë³€í™˜ ZIP(ì´ë¯¸ì§€ í¬ë§·ë§Œ)</option>
                </select>
                <div class="muted small mt-2">
                  ZIPì€ ê°œë³„ ì´ë¯¸ì§€ë¥¼ ì„ íƒí•œ í¬ë§·ìœ¼ë¡œ ë³€í™˜í•´ ë¬¶ì–´ì¤˜ìš”.
                </div>
              </div>

              <div class="chip rounded-2xl p-4">
                <div class="font-semibold">ì´ë¯¸ì§€ í¬ë§·</div>
                <select
                  id="imgFormat"
                  class="mt-2 w-full rounded-xl bg-black/30 border border-white/15 px-3 py-2"
                >
                  <option value="image/png">PNG</option>
                  <option value="image/jpeg">JPG</option>
                  <option value="image/webp">WEBP</option>
                </select>
                <div id="qualityWrap" class="mt-3">
                  <div class="flex items-center justify-between">
                    <div class="muted small">JPG/WEBP í’ˆì§ˆ</div>
                    <div class="small"><span id="qLabel">0.90</span></div>
                  </div>
                  <input
                    id="quality"
                    type="range"
                    min="0.4"
                    max="1"
                    step="0.02"
                    value="0.9"
                    class="w-full mt-2"
                  />
                </div>
              </div>
            </div>

            <div class="chip rounded-2xl p-4">
              <div class="flex items-start justify-between gap-3">
                <div>
                  <div class="font-semibold">í•©ì¹˜ê¸° ë ˆì´ì•„ì›ƒ</div>
                  <div class="muted small mt-1">
                    ì¶œë ¥ íƒ€ì…ì´ â€œí•©ì¹œ ì´ë¯¸ì§€â€ì¼ ë•Œ ì ìš©
                  </div>
                </div>
                <div class="small text-white/80">ìº”ë²„ìŠ¤ ê¸°ë°˜</div>
              </div>

              <div class="mt-3 grid sm:grid-cols-3 gap-2">
                <label
                  class="flex items-center gap-2 rounded-xl px-3 py-2 bg-white/5 border border-white/10 cursor-pointer"
                >
                  <input
                    type="radio"
                    name="layout"
                    value="vertical"
                    class="accent-green-500"
                    checked
                  />
                  <span>ì„¸ë¡œ</span>
                </label>
                <label
                  class="flex items-center gap-2 rounded-xl px-3 py-2 bg-white/5 border border-white/10 cursor-pointer"
                >
                  <input
                    type="radio"
                    name="layout"
                    value="horizontal"
                    class="accent-green-500"
                  />
                  <span>ê°€ë¡œ</span>
                </label>
                <label
                  class="flex items-center gap-2 rounded-xl px-3 py-2 bg-white/5 border border-white/10 cursor-pointer"
                >
                  <input
                    type="radio"
                    name="layout"
                    value="grid"
                    class="accent-green-500"
                  />
                  <span>ê·¸ë¦¬ë“œ</span>
                </label>
              </div>

              <label
                class="mt-3 flex items-center gap-2 rounded-xl px-3 py-2 bg-white/5 border border-white/10 cursor-pointer"
              >
                <input id="keepSize" type="checkbox" class="accent-green-500" />
                <div>
                  <div>ì›ë³¸ í¬ê¸° ê·¸ëŒ€ë¡œ ë¶™ì´ê¸°</div>
                  <div class="muted small">
                    ë¦¬ì‚¬ì´ì¦ˆ ì—†ì´ ê°„ê²© 0ìœ¼ë¡œ ì„¸ë¡œ/ê°€ë¡œ í•©ì¹˜ê¸°
                  </div>
                </div>
              </label>

              <div class="mt-4 grid sm:grid-cols-3 gap-3">
                <div>
                  <div class="muted small">ê°„ê²©(px)</div>
                  <input
                    id="gap"
                    type="number"
                    min="0"
                    value="16"
                    class="mt-1 w-full rounded-xl bg-black/30 border border-white/15 px-3 py-2"
                  />
                </div>
                <div>
                  <div class="muted small">ë°°ê²½</div>
                  <select
                    id="bg"
                    class="mt-1 w-full rounded-xl bg-black/30 border border-white/15 px-3 py-2"
                  >
                    <option value="#0b1220">ì–´ë‘ì›€</option>
                    <option value="#ffffff">í°ìƒ‰</option>
                    <option value="transparent">íˆ¬ëª…(PNGë§Œ)</option>
                  </select>
                </div>
                <div>
                  <div class="muted small">ê·¸ë¦¬ë“œ ì—´</div>
                  <input
                    id="cols"
                    type="number"
                    min="1"
                    max="8"
                    value="2"
                    class="mt-1 w-full rounded-xl bg-black/30 border border-white/15 px-3 py-2"
                  />
                </div>
              </div>

              <div class="mt-3 muted small">
                ğŸ’¡ íˆ¬ëª… ë°°ê²½ì€ <span class="text-white font-semibold">PNG</span>ì¼
                ë•Œë§Œ ì˜ë¯¸ê°€ ìˆì–´ìš”.
              </div>
            </div>

            <div class="chip rounded-2xl p-4">
              <div class="flex items-start justify-between gap-3">
                <div>
                  <div class="font-semibold">PDF ì„¤ì •</div>
                  <div class="muted small mt-1">ì¶œë ¥ íƒ€ì…ì´ PDFì¼ ë•Œ ì ìš©</div>
                </div>
                <div class="small text-white/80">í˜ì´ì§€ ë‹¨ìœ„</div>
              </div>

              <div class="mt-3 grid sm:grid-cols-3 gap-3">
                <div>
                  <div class="muted small">ìš©ì§€</div>
                  <select
                    id="pdfSize"
                    class="mt-1 w-full rounded-xl bg-black/30 border border-white/15 px-3 py-2"
                  >
                    <option value="a4">A4</option>
                    <option value="letter">Letter</option>
                    <option value="auto">ì´ë¯¸ì§€ì— ë§ì¶¤(ê¶Œì¥)</option>
                  </select>
                </div>
                <div>
                  <div class="muted small">ë°©í–¥</div>
                  <select
                    id="pdfOri"
                    class="mt-1 w-full rounded-xl bg-black/30 border border-white/15 px-3 py-2"
                  >
                    <option value="portrait">ì„¸ë¡œ</option>
                    <option value="landscape">ê°€ë¡œ</option>
                    <option value="auto">ìë™</option>
                  </select>
                </div>
                <div>
                  <div class="muted small">ì—¬ë°±(px)</div>
                  <input
                    id="pdfMargin"
                    type="number"
                    min="0"
                    value="24"
                    class="mt-1 w-full rounded-xl bg-black/30 border border-white/15 px-3 py-2"
                  />
                </div>
              </div>

              <div class="mt-3 grid sm:grid-cols-2 gap-2">
                <label
                  class="flex items-center gap-2 rounded-xl px-3 py-2 bg-white/5 border border-white/10 cursor-pointer"
                >
                  <input
                    id="pdfOnePerPage"
                    type="radio"
                    name="pdfMode"
                    value="one"
                    class="accent-green-500"
                    checked
                  />
                  <span>1í˜ì´ì§€ì— 1ì¥</span>
                </label>
                <label
                  class="flex items-center gap-2 rounded-xl px-3 py-2 bg-white/5 border border-white/10 cursor-pointer"
                >
                  <input
                    id="pdfGrid"
                    type="radio"
                    name="pdfMode"
                    value="grid"
                    class="accent-green-500"
                  />
                  <span>í•œ í˜ì´ì§€ ê·¸ë¦¬ë“œ</span>
                </label>
              </div>

              <div class="mt-3 muted small">
                ğŸ’¡ "ì´ë¯¸ì§€ì— ë§ì¶¤"ì€ ì´ë¯¸ì§€ í¬ê¸°ì— ë§ì¶° PDF í˜ì´ì§€ë¥¼ ì¡ì•„ì„œ
                <span class="text-white font-semibold">ì˜ë¦¼ì„ ìµœì†Œí™”</span>í•´ìš”.
              </div>
            </div>
          </div>

          <div class="mt-5 flex flex-col sm:flex-row gap-2">
            <button
              id="btnPreview"
              class="btn btn-ghost btn-sm w-full sm:w-auto"
              type="button"
            >
              ë¯¸ë¦¬ë³´ê¸°
            </button>
            <button
              id="btnMake"
              class="btn btn-primary w-full sm:flex-1 shadow-lg shadow-emerald-400/25"
              type="button"
            >
              ë‹¤ìš´ë¡œë“œ ë§Œë“¤ê¸°
            </button>
          </div>

          <div id="status" class="mt-4 muted small"></div>
        </div>
      </section>

      <!-- Preview -->
      <section class="mt-4 glass rounded-3xl p-5 ringy">
        <div class="flex items-start justify-between gap-3">
          <div>
            <h2 class="text-lg font-bold">3) ê²°ê³¼ ë¯¸ë¦¬ë³´ê¸°</h2>
            <p class="muted small mt-1">
              í•©ì¹œ ì´ë¯¸ì§€ëŠ” ì•„ë˜ ìº”ë²„ìŠ¤ë¡œ, PDFëŠ” í˜ì´ì§€ ìˆ˜/ìš©ëŸ‰ ì •ë³´ë¡œ ë¯¸ë¦¬
              í™•ì¸í•´ìš”.
            </p>
          </div>
          <a
            class="btn btn-ghost btn-sm"
            href="#top"
            onclick="window.scrollTo({top:0,behavior:'smooth'})"
            >ìœ„ë¡œ</a
          >
        </div>

        <div class="mt-4 grid lg:grid-cols-3 gap-4">
          <div class="lg:col-span-2">
            <div class="rounded-2xl border border-white/10 bg-black/30 p-3">
              <canvas
                id="canvas"
                class="w-full rounded-xl bg-black/40"
              ></canvas>
            </div>
            <div class="muted small mt-2">
              âš¡ ìº”ë²„ìŠ¤ëŠ” ë¸Œë¼ìš°ì € ì„±ëŠ¥ì— ë”°ë¼ í° ì´ë¯¸ì§€ì—ì„œ ì‹œê°„ì´ ê±¸ë¦´ ìˆ˜ ìˆì–´ìš”.
            </div>
          </div>

          <div class="chip rounded-2xl p-4">
            <div class="font-semibold">ì •ë³´</div>
            <div class="mt-3 space-y-2 small">
              <div class="flex justify-between">
                <span class="muted">ì´ ì´ë¯¸ì§€</span
                ><span id="infoCount">0</span>
              </div>
              <div class="flex justify-between">
                <span class="muted">ì˜ˆìƒ í¬ê¸°</span><span id="infoSize">-</span>
              </div>
              <div class="flex justify-between">
                <span class="muted">PDF í˜ì´ì§€</span
                ><span id="infoPages">-</span>
              </div>
              <div class="flex justify-between">
                <span class="muted">ìƒíƒœ</span><span id="infoState">ëŒ€ê¸°</span>
              </div>
            </div>

            <div
              class="mt-4 rounded-xl border border-white/10 bg-white/5 p-3 muted small"
            >
              ğŸ”’ ì´ í˜ì´ì§€ëŠ” ê¸°ë³¸ì ìœ¼ë¡œ
              <b class="text-white">ë¸Œë¼ìš°ì € ì•ˆì—ì„œ</b> ì²˜ë¦¬í•©ë‹ˆë‹¤.<br />
              (ëŒ€ìš©ëŸ‰/ì´ˆê³ í•´ìƒë„ëŠ” ëŠë¦´ ìˆ˜ ìˆì–´ìš”.)
            </div>
          </div>
        </div>
      </section>


      <footer class="mt-6 text-center muted small">
        Â© FunnyFunny Cloud â€” ë¹ ë¥´ê³  ê°€ë²¼ìš´ ì‹¤í—˜ì  ì›¹ì„œë¹„ìŠ¤
      </footer>
    </main>

    <!-- ZIP support (optional): JSZip via CDN -->
    <script src="https://cdn.jsdelivr.net/npm/jszip@3.10.1/dist/jszip.min.js"></script>

    <script>
      const $ = (id) => document.getElementById(id);

      const fileInput = $("fileInput");
      const dropzone = $("dropzone");
      const listEl = $("list");
      const emptyHint = $("emptyHint");
      const countEl = $("count");
      const statusEl = $("status");

      const outTypeEl = $("outType");
      const imgFormatEl = $("imgFormat");
      const qualityEl = $("quality");
      const qLabelEl = $("qLabel");
      const qualityWrap = $("qualityWrap");

      const gapEl = $("gap");
      const bgEl = $("bg");
      const colsEl = $("cols");
      const keepSizeEl = $("keepSize");

      const pdfSizeEl = $("pdfSize");
      const pdfOriEl = $("pdfOri");
      const pdfMarginEl = $("pdfMargin");

      const infoCountEl = $("infoCount");
      const infoSizeEl = $("infoSize");
      const infoPagesEl = $("infoPages");
      const infoStateEl = $("infoState");

      const canvas = $("canvas");
      const ctx = canvas.getContext("2d");

      /** @type {{id:string, name:string, file:File|null, src:string, img:HTMLImageElement, w:number, h:number}[]} */
      let items = [];

      function setStatus(msg, good = false) {
        statusEl.innerHTML = msg ? (good ? `âœ… ${msg}` : `â„¹ï¸ ${msg}`) : "";
      }

      function fmtBytes(bytes) {
        if (!Number.isFinite(bytes) || bytes <= 0) return "-";
        const units = ["B", "KB", "MB", "GB"];
        let i = 0,
          v = bytes;
        while (v >= 1024 && i < units.length - 1) {
          v /= 1024;
          i++;
        }
        return `${v.toFixed(i === 0 ? 0 : 2)} ${units[i]}`;
      }

      function updateQualityUI() {
        const mime = imgFormatEl.value;
        const show = mime === "image/jpeg" || mime === "image/webp";
        qualityWrap.style.display = show ? "block" : "none";
        qLabelEl.textContent = Number(qualityEl.value).toFixed(2);
      }
      qualityEl.addEventListener("input", updateQualityUI);
      imgFormatEl.addEventListener("change", () => {
        updateQualityUI();
        syncBgForTransparency();
      });

      function syncBgForTransparency() {
        // transparent only makes sense for PNG
        if (bgEl.value === "transparent" && imgFormatEl.value !== "image/png") {
          bgEl.value = "#0b1220";
        }
        if (imgFormatEl.value !== "image/png") {
          // keep option but warn via status
          if (bgEl.value === "transparent") bgEl.value = "#0b1220";
        }
      }
      bgEl.addEventListener("change", syncBgForTransparency);

      function syncGapForKeepSize() {
        if (keepSizeEl.checked) {
          gapEl.value = "0";
          gapEl.disabled = true;
        } else {
          gapEl.disabled = false;
        }
      }
      keepSizeEl.addEventListener("change", () => {
        syncGapForKeepSize();
        preview();
      });

      function uid() {
        return Math.random().toString(16).slice(2) + Date.now().toString(16);
      }

      async function fileToImage(file) {
        const src = URL.createObjectURL(file);
        const img = new Image();
        img.decoding = "async";
        img.loading = "eager";
        await new Promise((res, rej) => {
          img.onload = () => res();
          img.onerror = () => rej(new Error("ì´ë¯¸ì§€ë¥¼ ì½ì„ ìˆ˜ ì—†ì–´ìš”."));
          img.src = src;
        });
        return { src, img, w: img.naturalWidth, h: img.naturalHeight };
      }

      async function addFiles(files) {
        const arr = [...files].filter(
          (f) => f && f.type && f.type.startsWith("image/")
        );
        if (!arr.length) {
          setStatus("ì´ë¯¸ì§€ íŒŒì¼ë§Œ ë„£ì„ ìˆ˜ ìˆì–´ìš”.");
          return;
        }

        setStatus(`ì´ë¯¸ì§€ ${arr.length}ì¥ ë¶ˆëŸ¬ì˜¤ëŠ” ì¤‘...`);
        infoStateEl.textContent = "ë¡œë”©";

        for (const f of arr) {
          try {
            const { src, img, w, h } = await fileToImage(f);
            items.push({
              id: uid(),
              name: f.name || "image",
              file: f,
              src,
              img,
              w,
              h,
            });
          } catch (e) {
            console.warn(e);
          }
        }
        renderList();
        await preview(); // auto preview
        setStatus("ì—…ë¡œë“œ ì™„ë£Œ!", true);
        infoStateEl.textContent = "ëŒ€ê¸°";
      }

      function cleanup() {
        for (const it of items) {
          try {
            if (it.src?.startsWith("blob:")) URL.revokeObjectURL(it.src);
          } catch {}
        }
        items = [];
        renderList();
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        canvas.width = 1;
        canvas.height = 1;
        setStatus("");
        infoPagesEl.textContent = "-";
        infoSizeEl.textContent = "-";
        infoStateEl.textContent = "ëŒ€ê¸°";
      }

      function renderList() {
        listEl.innerHTML = "";
        countEl.textContent = String(items.length);
        infoCountEl.textContent = String(items.length);

        emptyHint.style.display = items.length ? "none" : "block";

        for (const it of items) {
          const card = document.createElement("div");
          card.className =
            "rounded-2xl border border-white/10 bg-white/5 p-3 flex gap-3 items-center";
          card.dataset.id = it.id;

          const thumb = document.createElement("img");
          thumb.src = it.src;
          thumb.alt = "thumb";
          thumb.className =
            "w-20 h-16 object-cover rounded-xl border border-white/10 bg-black/30";

          const meta = document.createElement("div");
          meta.className = "min-w-0 flex-1";
          meta.innerHTML = `
          <div class="font-semibold truncate">${escapeHtml(it.name)}</div>
          <div class="muted small">${it.w}Ã—${it.h}</div>
        `;

          const btns = document.createElement("div");
          btns.className = "flex gap-2";
          const del = document.createElement("button");
          del.className = "btn btn-ghost btn-sm";
          del.type = "button";
          del.textContent = "ì‚­ì œ";
          del.onclick = () => {
            items = items.filter((x) => x.id !== it.id);
            try {
              if (it.src?.startsWith("blob:")) URL.revokeObjectURL(it.src);
            } catch {}
            renderList();
            preview();
          };

          btns.appendChild(del);

          card.appendChild(thumb);
          card.appendChild(meta);
          card.appendChild(btns);

          listEl.appendChild(card);
        }
      }

      function escapeHtml(s) {
        return String(s).replace(
          /[&<>"']/g,
          (m) =>
            ({
              "&": "&amp;",
              "<": "&lt;",
              ">": "&gt;",
              '"': "&quot;",
              "'": "&#039;",
            }[m])
        );
      }

      // Drag reorder
      new Sortable(listEl, {
        animation: 160,
        ghostClass: "opacity-40",
        onEnd: () => {
          const order = [...listEl.querySelectorAll("[data-id]")].map(
            (el) => el.dataset.id
          );
          items.sort((a, b) => order.indexOf(a.id) - order.indexOf(b.id));
          preview();
        },
      });

      // Dropzone events
      ["dragenter", "dragover"].forEach((ev) =>
        dropzone.addEventListener(ev, (e) => {
          e.preventDefault();
          dropzone.classList.add("drop-active");
        })
      );
      ["dragleave", "drop"].forEach((ev) =>
        dropzone.addEventListener(ev, (e) => {
          e.preventDefault();
          dropzone.classList.remove("drop-active");
        })
      );
      dropzone.addEventListener("drop", (e) => addFiles(e.dataTransfer.files));

      fileInput.addEventListener("change", (e) => addFiles(e.target.files));
      $("btnClear").addEventListener("click", cleanup);

      function getLayout() {
        return (
          document.querySelector('input[name="layout"]:checked')?.value ||
          "vertical"
        );
      }
      function getPdfMode() {
        return (
          document.querySelector('input[name="pdfMode"]:checked')?.value ||
          "one"
        );
      }

      function bgColor() {
        return bgEl.value === "transparent" ? null : bgEl.value;
      }

      function clampInt(v, def, min, max) {
        const n = Math.floor(Number(v));
        if (!Number.isFinite(n)) return def;
        return Math.max(min, Math.min(max, n));
      }

      async function preview() {
        try {
          if (!items.length) {
            infoSizeEl.textContent = "-";
            infoPagesEl.textContent = "-";
            infoStateEl.textContent = "ëŒ€ê¸°";
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            return;
          }

          infoStateEl.textContent = "ë¯¸ë¦¬ë³´ê¸°";
          const outType = outTypeEl.value;

          if (outType === "pdf") {
            // For PDF, we don't render all pages; show page count expectation.
            const mode = getPdfMode();
            infoPagesEl.textContent =
              mode === "one" ? String(items.length) : "1";
            // Show rough size as sum of original file sizes (very rough)
            const approx = items.reduce((a, it) => a + (it.file?.size || 0), 0);
            infoSizeEl.textContent = `~${fmtBytes(approx)}`;
            infoStateEl.textContent = "ëŒ€ê¸°";
            // still show a merged preview canvas (first few) for UX
          } else {
            infoPagesEl.textContent = "-";
          }

          // Always draw a merged canvas preview (based on current layout)
          const layout = getLayout();
          const keepSize = keepSizeEl.checked;
          const gap = keepSize ? 0 : Math.max(0, Number(gapEl.value) || 0);
          const cols = clampInt(colsEl.value, 2, 1, 8);

          // Scale preview to keep it reasonable
          const PREVIEW_MAX = 2200; // px
          const {
            w: cw,
            h: ch,
            placements,
          } = computeLayout(items, layout, gap, cols, keepSize);

          const scale = Math.min(1, PREVIEW_MAX / Math.max(cw, ch));
          canvas.width = Math.max(1, Math.floor(cw * scale));
          canvas.height = Math.max(1, Math.floor(ch * scale));

          // background
          ctx.clearRect(0, 0, canvas.width, canvas.height);
          const bg = bgColor();
          if (bg) {
            ctx.fillStyle = bg;
            ctx.fillRect(0, 0, canvas.width, canvas.height);
          }

          // draw
          for (const p of placements) {
            const dx = Math.floor(p.x * scale);
            const dy = Math.floor(p.y * scale);
            const dw = Math.floor(p.w * scale);
            const dh = Math.floor(p.h * scale);
            ctx.drawImage(p.img, dx, dy, dw, dh);
          }

          // size estimate by encoding preview (approx)
          try {
            const mime = outType === "image" ? imgFormatEl.value : "image/png";
            const q = Number(qualityEl.value) || 0.9;
            const dataUrl = canvas.toDataURL(mime, q);
            const bytes = Math.floor(
              ((dataUrl.length - dataUrl.indexOf(",") - 1) * 3) / 4
            );
            infoSizeEl.textContent =
              fmtBytes(bytes) + (outType === "pdf" ? " (preview)" : "");
          } catch {
            infoSizeEl.textContent = "-";
          }
          infoStateEl.textContent = "ëŒ€ê¸°";
        } catch (e) {
          console.error(e);
          setStatus("ë¯¸ë¦¬ë³´ê¸° ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆì–´ìš”. ì„¤ì •ì„ ë‹¤ì‹œ í™•ì¸í•´ì£¼ì„¸ìš”.");
          infoStateEl.textContent = "ì˜¤ë¥˜";
        }
      }

      function computeLayout(items, layout, gap, cols, keepSize = false) {
        // Strategy:
        // - vertical/horizontal: normalize widths/heights to a common edge to look consistent.
        // - grid: each cell size = max cell width among images normalized by aspect (simple).
        const imgs = items.map((it) => ({
          img: it.img,
          w: it.w,
          h: it.h,
          a: it.w / it.h,
        }));

        if (layout === "horizontal") {
          if (keepSize) {
            let x = 0;
            let maxH = 0;
            const placements = imgs.map((xi) => {
              const p = { img: xi.img, x, y: 0, w: xi.w, h: xi.h };
              x += xi.w + gap;
              maxH = Math.max(maxH, xi.h);
              return p;
            });
            const W = Math.max(1, x - gap);
            const H = Math.max(1, maxH);
            return { w: W, h: H, placements };
          }
          // common height
          const H = median(imgs.map((x) => x.h));
          let x = 0;
          const placements = imgs.map((xi) => {
            const w = Math.round(H * xi.a);
            const p = { img: xi.img, x, y: 0, w, h: H };
            x += w + gap;
            return p;
          });
          const W = Math.max(1, x - gap);
          return { w: W, h: H, placements };
        }

        if (layout === "grid") {
          const C = Math.max(1, cols);
          // choose a target cell width from median widths
          const cellW = Math.max(240, Math.round(median(imgs.map((x) => x.w))));
          const cellH = Math.max(180, Math.round(cellW * 0.75));
          const placements = [];
          let maxX = 0,
            maxY = 0;

          imgs.forEach((xi, i) => {
            const r = Math.floor(i / C);
            const c = i % C;
            const x = c * (cellW + gap);
            const y = r * (cellH + gap);

            // fit image into cell preserving aspect (contain)
            const scale = Math.min(cellW / xi.w, cellH / xi.h);
            const w = Math.round(xi.w * scale);
            const h = Math.round(xi.h * scale);
            const ox = x + Math.round((cellW - w) / 2);
            const oy = y + Math.round((cellH - h) / 2);

            placements.push({ img: xi.img, x: ox, y: oy, w, h });

            maxX = Math.max(maxX, x + cellW);
            maxY = Math.max(maxY, y + cellH);
          });

          const W = maxX;
          const H = maxY;
          return { w: W, h: H, placements };
        }

        // vertical default: common width
        if (keepSize) {
          let y = 0;
          let maxW = 0;
          const placements = imgs.map((xi) => {
            const p = { img: xi.img, x: 0, y, w: xi.w, h: xi.h };
            y += xi.h + gap;
            maxW = Math.max(maxW, xi.w);
            return p;
          });
          const H = Math.max(1, y - gap);
          const W = Math.max(1, maxW);
          return { w: W, h: H, placements };
        }
        const W = median(imgs.map((x) => x.w));
        let y = 0;
        const placements = imgs.map((xi) => {
          const h = Math.round(W / xi.a);
          const p = { img: xi.img, x: 0, y, w: W, h };
          y += h + gap;
          return p;
        });
        const H = Math.max(1, y - gap);
        return { w: W, h: H, placements };
      }

      function median(arr) {
        const a = [...arr]
          .filter((n) => Number.isFinite(n))
          .sort((x, y) => x - y);
        if (!a.length) return 800;
        const mid = Math.floor(a.length / 2);
        return a.length % 2 ? a[mid] : Math.round((a[mid - 1] + a[mid]) / 2);
      }

      // Build outputs
      async function buildMergedImageBlob() {
        if (!items.length) throw new Error("ì´ë¯¸ì§€ë¥¼ ë¨¼ì € ì¶”ê°€í•´ì£¼ì„¸ìš”.");

        const layout = getLayout();
        const keepSize = keepSizeEl.checked;
        const gap = keepSize ? 0 : Math.max(0, Number(gapEl.value) || 0);
        const cols = clampInt(colsEl.value, 2, 1, 8);

        const { w, h, placements } = computeLayout(
          items,
          layout,
          gap,
          cols,
          keepSize
        );

        // Use offscreen canvas for full-res output
        const off = document.createElement("canvas");
        off.width = Math.max(1, Math.floor(w));
        off.height = Math.max(1, Math.floor(h));
        const c = off.getContext("2d");

        const bg = bgColor();
        if (bg) {
          c.fillStyle = bg;
          c.fillRect(0, 0, off.width, off.height);
        } else {
          c.clearRect(0, 0, off.width, off.height);
        }

        for (const p of placements) {
          c.drawImage(p.img, p.x, p.y, p.w, p.h);
        }

        const mime = imgFormatEl.value;
        const q = Number(qualityEl.value) || 0.9;

        // transparency only meaningful for png
        const blob = await new Promise((res) => off.toBlob(res, mime, q));
        if (!blob) throw new Error("ì´ë¯¸ì§€ ìƒì„±ì— ì‹¤íŒ¨í–ˆì–´ìš”.");
        return blob;
      }

      async function buildPdfBlob() {
        if (!items.length) throw new Error("ì´ë¯¸ì§€ë¥¼ ë¨¼ì € ì¶”ê°€í•´ì£¼ì„¸ìš”.");
        const { jsPDF } = window.jspdf;

        const mode = getPdfMode();
        const sizeOpt = pdfSizeEl.value;
        const marginPx = Math.max(0, Number(pdfMarginEl.value) || 0);

        // helper: px->pt (rough). We'll keep consistent by using px as unit directly with jsPDF "px".
        // jsPDF supports unit: 'px' (with hotfix). We'll use px to simplify.
        const unit = "px";

        // Determine orientation per page if auto
        const oriOpt = pdfOriEl.value;

        let doc = null;
        let pages = 0;

        if (mode === "grid") {
          // One page grid using current grid settings
          const gap = Math.max(0, Number(gapEl.value) || 0);
          const cols = clampInt(colsEl.value, 2, 1, 8);
          const { w, h, placements } = computeLayout(items, "grid", gap, cols);

          // Page size
          const pageW = sizeOpt === "auto" ? w + marginPx * 2 : undefined;
          const pageH = sizeOpt === "auto" ? h + marginPx * 2 : undefined;

          const orientation = resolveOrientation(oriOpt, w, h);
          doc = new jsPDF({
            unit,
            format: sizeOpt === "auto" ? [pageW, pageH] : sizeOpt,
            orientation,
          });

          // background (optional)
          // We'll draw images onto a canvas first for speed, then add as one image
          const off = document.createElement("canvas");
          off.width = Math.max(1, Math.floor(w));
          off.height = Math.max(1, Math.floor(h));
          const c = off.getContext("2d");
          c.fillStyle = "#ffffff";
          c.fillRect(0, 0, off.width, off.height);
          for (const p of placements) c.drawImage(p.img, p.x, p.y, p.w, p.h);

          const imgData = off.toDataURL("image/jpeg", 0.92);
          doc.addImage(imgData, "JPEG", marginPx, marginPx, w, h);
          pages = 1;
        } else {
          // One per page
          for (let i = 0; i < items.length; i++) {
            const it = items[i];
            const w = it.w,
              h = it.h;

            const orientation = resolveOrientation(oriOpt, w, h);

            if (!doc) {
              const format =
                sizeOpt === "auto"
                  ? [w + marginPx * 2, h + marginPx * 2]
                  : sizeOpt;
              doc = new jsPDF({ unit, format, orientation });
            } else {
              const format =
                sizeOpt === "auto"
                  ? [w + marginPx * 2, h + marginPx * 2]
                  : sizeOpt;
              doc.addPage(format, orientation);
            }

            // fit image into page area (contain)
            const page = doc.internal.pageSize;
            const pageW = page.getWidth();
            const pageH = page.getHeight();

            const maxW = pageW - marginPx * 2;
            const maxH = pageH - marginPx * 2;

            const scale = Math.min(maxW / w, maxH / h);
            const dw = w * scale;
            const dh = h * scale;
            const x = marginPx + (maxW - dw) / 2;
            const y = marginPx + (maxH - dh) / 2;

            // encode per image (jpeg for speed; png is big)
            const dataUrl = imageToDataURL(it.img, "image/jpeg", 0.92);
            doc.addImage(dataUrl, "JPEG", x, y, dw, dh);
            pages++;
          }
        }

        infoPagesEl.textContent = String(pages);

        const blob = doc.output("blob");
        return blob;
      }

      function resolveOrientation(opt, w, h) {
        if (opt === "auto") return w >= h ? "landscape" : "portrait";
        return opt;
      }

      function imageToDataURL(img, mime, quality) {
        const c = document.createElement("canvas");
        c.width = img.naturalWidth || img.width;
        c.height = img.naturalHeight || img.height;
        const x = c.getContext("2d");
        x.fillStyle = "#ffffff";
        x.fillRect(0, 0, c.width, c.height);
        x.drawImage(img, 0, 0);
        return c.toDataURL(mime, quality);
      }

      function downloadBlob(blob, filename) {
        const a = document.createElement("a");
        const url = URL.createObjectURL(blob);
        a.href = url;
        a.download = filename;
        document.body.appendChild(a);
        a.click();
        a.remove();
        setTimeout(() => URL.revokeObjectURL(url), 1500);
      }

      async function buildZipOfConvertedImages() {
        if (!items.length) throw new Error("ì´ë¯¸ì§€ë¥¼ ë¨¼ì € ì¶”ê°€í•´ì£¼ì„¸ìš”.");
        if (!window.JSZip) throw new Error("ZIP ëª¨ë“ˆ ë¡œë“œ ì‹¤íŒ¨");

        const zip = new JSZip();
        const mime = imgFormatEl.value;
        const q = Number(qualityEl.value) || 0.9;

        for (let i = 0; i < items.length; i++) {
          const it = items[i];
          const dataUrl = imageToDataURL(it.img, mime, q);
          const base64 = dataUrl.split(",")[1];
          const ext =
            mime === "image/png"
              ? "png"
              : mime === "image/webp"
              ? "webp"
              : "jpg";
          const safe = (it.name || `image-${i + 1}`)
            .replace(/[^\w.-]+/g, "_")
            .replace(/\.+$/, "");
          zip.file(`${String(i + 1).padStart(2, "0")}_${safe}.${ext}`, base64, {
            base64: true,
          });
        }

        const blob = await zip.generateAsync({ type: "blob" });
        return blob;
      }

      $("btnPreview").addEventListener("click", preview);

      $("btnMake").addEventListener("click", async () => {
        try {
          if (!items.length) {
            setStatus("ì´ë¯¸ì§€ë¥¼ ë¨¼ì € ì¶”ê°€í•´ì£¼ì„¸ìš”.");
            return;
          }
          infoStateEl.textContent = "ìƒì„±ì¤‘";
          setStatus("ë§Œë“œëŠ” ì¤‘... (í° ì´ë¯¸ì§€ëŠ” ì‹œê°„ì´ ê±¸ë¦´ ìˆ˜ ìˆì–´ìš”)");

          const outType = outTypeEl.value;

          if (outType === "image") {
            const blob = await buildMergedImageBlob();
            const ext =
              imgFormatEl.value === "image/png"
                ? "png"
                : imgFormatEl.value === "image/webp"
                ? "webp"
                : "jpg";
            downloadBlob(blob, `merged.${ext}`);
            setStatus("í•©ì¹œ ì´ë¯¸ì§€ë¥¼ ë‹¤ìš´ë¡œë“œí–ˆì–´ìš”!", true);
          } else if (outType === "pdf") {
            const blob = await buildPdfBlob();
            downloadBlob(blob, "images.pdf");
            setStatus("PDF ë‹¤ìš´ë¡œë“œ ì™„ë£Œ!", true);
          } else if (outType === "zip") {
            if (
              imgFormatEl.value === "image/png" ||
              imgFormatEl.value === "image/jpeg" ||
              imgFormatEl.value === "image/webp"
            ) {
              const blob = await buildZipOfConvertedImages();
              downloadBlob(blob, "converted_images.zip");
              setStatus("ZIP ë‹¤ìš´ë¡œë“œ ì™„ë£Œ!", true);
            } else {
              setStatus("ZIPì€ ì´ë¯¸ì§€ í¬ë§·(PNG/JPG/WEBP)ì—ì„œë§Œ ì§€ì›í•´ìš”.");
            }
          }

          await preview();
        } catch (e) {
          console.error(e);
          setStatus(e?.message || "ìƒì„± ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆì–´ìš”.");
        } finally {
          infoStateEl.textContent = "ëŒ€ê¸°";
        }
      });

      // If output type changes, adjust preview info
      outTypeEl.addEventListener("change", () => {
        const t = outTypeEl.value;
        // If zip selected, merged layout still used for preview; ok
        preview();
      });

      // live preview on setting changes (lightweight ones)
      [gapEl, colsEl, bgEl, pdfSizeEl, pdfOriEl, pdfMarginEl].forEach((el) => {
        el.addEventListener("input", () => preview());
        el.addEventListener("change", () => preview());
      });
      document
        .querySelectorAll('input[name="layout"]')
        .forEach((r) => r.addEventListener("change", preview));
      document
        .querySelectorAll('input[name="pdfMode"]')
        .forEach((r) => r.addEventListener("change", preview));



      // HTML file to PDF conversion
      let uploadedHtmlContent = null;
      let uploadedHtmlFileName = null;
      let htmlIframe = null;
      let uploadedImageFiles = new Map(); // íŒŒì¼ëª… -> File ê°ì²´

      const htmlFileInput = $("htmlFileInput");
      const htmlDropzone = $("htmlDropzone");
      const htmlPreview = $("htmlPreview");
      const htmlFileName = $("htmlFileName");
      const btnClearHtml = $("btnClearHtml");
      const btnConvertHtmlToPdf = $("btnConvertHtmlToPdf");
      const htmlStatus = $("htmlStatus");

      function setHtmlStatus(msg, good = false) {
        htmlStatus.innerHTML = msg ? (good ? `âœ… ${msg}` : `â„¹ï¸ ${msg}`) : "";
      }

      // íŒŒì¼ì„ base64 data URLë¡œ ë³€í™˜
      function fileToDataURL(file) {
        return new Promise((resolve, reject) => {
          const reader = new FileReader();
          reader.onload = () => resolve(reader.result);
          reader.onerror = reject;
          reader.readAsDataURL(file);
        });
      }

      // HTML ë‚´ë¶€ì˜ ì´ë¯¸ì§€ ê²½ë¡œë¥¼ base64ë¡œ ë³€í™˜
      async function convertImagePathsToBase64(htmlText, imageFiles) {
        // HTMLì„ íŒŒì‹±í•˜ê¸° ìœ„í•œ ì„ì‹œ DOM
        const parser = new DOMParser();
        const doc = parser.parseFromString(htmlText, "text/html");

        // ëª¨ë“  img íƒœê·¸ ì°¾ê¸°
        const images = doc.querySelectorAll("img");
        let modified = false;

        for (const img of images) {
          const src = img.getAttribute("src");
          if (!src) continue;

          // ì´ë¯¸ base64ë‚˜ data URLì¸ ê²½ìš° ìŠ¤í‚µ
          if (src.startsWith("data:") || src.startsWith("blob:")) continue;

          // ì ˆëŒ€ URLì¸ ê²½ìš°ë„ ìŠ¤í‚µ (ì™¸ë¶€ ì´ë¯¸ì§€)
          if (src.startsWith("http://") || src.startsWith("https://")) continue;

          // íŒŒì¼ëª… ì¶”ì¶œ (ê²½ë¡œì—ì„œ ë§ˆì§€ë§‰ ë¶€ë¶„ë§Œ)
          const fileName = src.split("/").pop().split("\\").pop();

          // ì´ë¯¸ì§€ íŒŒì¼ ì°¾ê¸°
          let imageFile = null;

          // ì •í™•í•œ íŒŒì¼ëª… ë§¤ì¹­
          if (imageFiles.has(fileName)) {
            imageFile = imageFiles.get(fileName);
          } else {
            // ëŒ€ì†Œë¬¸ì ë¬´ì‹œ ë§¤ì¹­
            for (const [name, file] of imageFiles.entries()) {
              if (name.toLowerCase() === fileName.toLowerCase()) {
                imageFile = file;
                break;
              }
            }
          }

          if (imageFile) {
            try {
              const dataURL = await fileToDataURL(imageFile);
              img.setAttribute("src", dataURL);
              modified = true;
            } catch (e) {
              console.warn(`ì´ë¯¸ì§€ ë³€í™˜ ì‹¤íŒ¨: ${fileName}`, e);
            }
          } else {
            console.warn(`ì´ë¯¸ì§€ íŒŒì¼ì„ ì°¾ì„ ìˆ˜ ì—†ìŒ: ${fileName}`);
          }
        }

        if (modified) {
          return doc.documentElement.outerHTML;
        }
        return htmlText;
      }

      async function loadHtmlFile(files) {
        try {
          // ì—¬ëŸ¬ íŒŒì¼ ì¤‘ HTML íŒŒì¼ ì°¾ê¸°
          const fileArray =
            files instanceof FileList ? Array.from(files) : [files];
          const htmlFile = fileArray.find((f) =>
            f.name.match(/\.(html|htm)$/i)
          );

          if (!htmlFile) {
            setHtmlStatus("HTML íŒŒì¼ì„ ì°¾ì„ ìˆ˜ ì—†ì–´ìš”.");
            return;
          }

          // ì´ë¯¸ì§€ íŒŒì¼ë“¤ ì €ì¥
          uploadedImageFiles.clear();
          fileArray.forEach((file) => {
            if (file !== htmlFile && file.type.startsWith("image/")) {
              // íŒŒì¼ëª…ì„ í‚¤ë¡œ ì‚¬ìš© (ëŒ€ì†Œë¬¸ì êµ¬ë¶„)
              uploadedImageFiles.set(file.name, file);
            }
          });

          setHtmlStatus("HTML íŒŒì¼ ì½ëŠ” ì¤‘...");
          let htmlText = await htmlFile.text();

          // ì´ë¯¸ì§€ ê²½ë¡œë¥¼ base64ë¡œ ë³€í™˜
          if (uploadedImageFiles.size > 0) {
            setHtmlStatus("ì´ë¯¸ì§€ ê²½ë¡œ ë³€í™˜ ì¤‘...");
            htmlText = await convertImagePathsToBase64(
              htmlText,
              uploadedImageFiles
            );
          }

          uploadedHtmlContent = htmlText;
          uploadedHtmlFileName = htmlFile.name;

          // ë¯¸ë¦¬ë³´ê¸° iframe ìƒì„±
          if (htmlIframe) {
            htmlIframe.remove();
          }
          htmlIframe = document.createElement("iframe");
          htmlIframe.style.width = "100%";
          htmlIframe.style.minHeight = "400px";
          htmlIframe.style.border = "none";
          htmlIframe.style.borderRadius = "8px";
          htmlIframe.style.backgroundColor = "#ffffff";
          htmlPreview.style.overflow = "auto";
          htmlPreview.style.maxHeight = "600px";
          htmlPreview.innerHTML = "";
          htmlPreview.appendChild(htmlIframe);

          // iframeì— HTML ë‚´ìš© ì“°ê¸°
          htmlIframe.onload = () => {
            const iframeDoc =
              htmlIframe.contentDocument || htmlIframe.contentWindow.document;
            const iframeWindow = htmlIframe.contentWindow;

            // ì‹¤ì œ ì½˜í…ì¸  í¬ê¸°ì— ë§ì¶° iframe í¬ê¸° ì¡°ì •
            setTimeout(() => {
              try {
                const contentHeight = Math.max(
                  iframeDoc.body?.scrollHeight || iframeDoc.documentElement?.scrollHeight || 400,
                  iframeDoc.body?.offsetHeight || 400
                );
                
                // ìµœëŒ€ ë†’ì´ ì œí•œ (600px ì»¨í…Œì´ë„ˆì— ë§ì¶¤)
                htmlIframe.style.height = Math.min(contentHeight, 800) + "px";
              } catch (e) {
                console.warn("iframe í¬ê¸° ì¡°ì • ì‹¤íŒ¨:", e);
                htmlIframe.style.height = "400px";
              }

              setHtmlStatus("HTML íŒŒì¼ ë¡œë“œ ì™„ë£Œ!", true);
              btnConvertHtmlToPdf.disabled = false;
            }, 200);
          };

          htmlIframe.srcdoc = htmlText;
          const imageCount = uploadedImageFiles.size;
          htmlFileName.textContent =
            htmlFile.name +
            (imageCount > 0 ? ` (ì´ë¯¸ì§€ ${imageCount}ê°œ í¬í•¨)` : "");
          btnClearHtml.style.display = "block";
        } catch (e) {
          console.error(e);
          setHtmlStatus("HTML íŒŒì¼ì„ ì½ì„ ìˆ˜ ì—†ì–´ìš”: " + e.message);
        }
      }

      function clearHtmlFile() {
        uploadedHtmlContent = null;
        uploadedHtmlFileName = null;
        uploadedImageFiles.clear();
        if (htmlIframe) {
          htmlIframe.remove();
          htmlIframe = null;
        }
        htmlPreview.innerHTML =
          '<div class="muted small text-center py-8">ğŸ“„ HTML íŒŒì¼ì„ ì—…ë¡œë“œí•˜ë©´ ì—¬ê¸°ì— ë¯¸ë¦¬ë³´ê¸°ê°€ í‘œì‹œë©ë‹ˆë‹¤.</div>';
        htmlFileName.textContent = "";
        btnClearHtml.style.display = "none";
        btnConvertHtmlToPdf.disabled = true;
        setHtmlStatus("");
      }

      // ëª¨ë“  ì´ë¯¸ì§€ê°€ ë¡œë“œë  ë•Œê¹Œì§€ ê¸°ë‹¤ë¦¬ëŠ” í•¨ìˆ˜
      function waitForImages(doc) {
        return new Promise((resolve) => {
          const images = doc.querySelectorAll("img");
          if (images.length === 0) {
            resolve();
            return;
          }

          let loaded = 0;
          let hasError = false;

          const checkComplete = () => {
            loaded++;
            if (loaded === images.length) {
              // ëª¨ë“  ì´ë¯¸ì§€ ë¡œë“œ ì™„ë£Œ í›„ ì•½ê°„ì˜ ì¶”ê°€ ëŒ€ê¸° (ë Œë”ë§ ì™„ë£Œ ë³´ì¥)
              setTimeout(resolve, 300);
            }
          };

          images.forEach((img) => {
            if (img.complete && img.naturalHeight !== 0) {
              // ì´ë¯¸ ë¡œë“œëœ ì´ë¯¸ì§€
              checkComplete();
            } else {
              // ë¡œë”© ì¤‘ì¸ ì´ë¯¸ì§€
              img.onload = checkComplete;
              img.onerror = () => {
                hasError = true;
                checkComplete(); // ì—ëŸ¬ê°€ ë‚˜ë„ ê³„ì† ì§„í–‰
              };
              // ì´ë¯¸ ë¡œë“œëœ ê²½ìš°ë¥¼ ëŒ€ë¹„í•´ ë‹¤ì‹œ í™•ì¸
              if (img.complete) {
                checkComplete();
              }
            }
          });
        });
      }

      async function convertHtmlFileToPdf() {
        try {
          if (!uploadedHtmlContent || !htmlIframe) {
            setHtmlStatus("ë¨¼ì € HTML íŒŒì¼ì„ ì—…ë¡œë“œí•´ì£¼ì„¸ìš”.");
            return;
          }

          if (!window.html2canvas || !window.jspdf) {
            setHtmlStatus("PDF ë³€í™˜ ë¼ì´ë¸ŒëŸ¬ë¦¬ë¥¼ ë¶ˆëŸ¬ì˜¬ ìˆ˜ ì—†ì–´ìš”.");
            return;
          }

          setHtmlStatus("ì´ë¯¸ì§€ ë¡œë”© ì¤‘...");
          btnConvertHtmlToPdf.disabled = true;

          // iframeì˜ ë‚´ìš©ì„ ìº¡ì²˜
          const iframeDoc =
            htmlIframe.contentDocument || htmlIframe.contentWindow.document;
          const iframeBody = iframeDoc.body;
          const iframeWindow = htmlIframe.contentWindow;

          // ëª¨ë“  ì´ë¯¸ì§€ê°€ ë¡œë“œë  ë•Œê¹Œì§€ ëŒ€ê¸°
          await waitForImages(iframeDoc);

          // ì¶”ê°€ ë Œë”ë§ ëŒ€ê¸° ì‹œê°„
          await new Promise((resolve) => setTimeout(resolve, 500));

          setHtmlStatus("PDF ë³€í™˜ ì¤‘... (í˜ì´ì§€ê°€ ê¸¸ë©´ ì‹œê°„ì´ ê±¸ë¦´ ìˆ˜ ìˆì–´ìš”)");

          // ì‹¤ì œ ë·°í¬íŠ¸ í¬ê¸° ê°€ì ¸ì˜¤ê¸° (iframe ë‚´ë¶€ì˜ ì‹¤ì œ ë Œë”ë§ í¬ê¸°)
          const contentWidth = Math.max(
            iframeBody.scrollWidth || iframeBody.offsetWidth || 1920,
            iframeWindow.innerWidth || 1920
          );
          const contentHeight = Math.max(
            iframeBody.scrollHeight || iframeBody.offsetHeight || 1080,
            iframeWindow.innerHeight || 1080
          );

          // html2canvasë¡œ iframe ë‚´ìš©ì„ ìº”ë²„ìŠ¤ë¡œ ë³€í™˜ (ê³ í•´ìƒë„ë¡œ ì„ ëª…í•˜ê²Œ)
          const scale = 2; // ê³ í•´ìƒë„ë¡œ ì„ ëª…í•˜ê²Œ
          const canvas = await html2canvas(iframeBody, {
            scale: scale, // ê³ í•´ìƒë„ë¡œ ì„ ëª…í•˜ê²Œ
            useCORS: true,
            allowTaint: true, // trueë¡œ ë³€ê²½í•˜ì—¬ ëª¨ë“  ì´ë¯¸ì§€ í¬í•¨ (ë³´ì•ˆ ê²½ê³  ë¬´ì‹œ)
            logging: false,
            backgroundColor: "#ffffff",
            width: contentWidth,
            height: contentHeight,
            windowWidth: contentWidth,
            windowHeight: contentHeight,
            x: 0,
            y: 0,
            removeContainer: false,
            imageTimeout: 30000, // íƒ€ì„ì•„ì›ƒ ì¦ê°€ (30ì´ˆ)
            foreignObjectRendering: false, // ì™¸ë¶€ ê°ì²´ ë Œë”ë§ ë¹„í™œì„±í™” (í˜¸í™˜ì„±)
            onclone: (clonedDoc) => {
              // í´ë¡ ëœ ë¬¸ì„œì—ì„œ ìŠ¤íƒ€ì¼ ë³´ì • (ë²„íŠ¼ì´ í‹€ì–´ì§€ì§€ ì•Šë„ë¡)
              const clonedBody = clonedDoc.body;
              if (clonedBody) {
                clonedBody.style.transform = "none";
                clonedBody.style.transformOrigin = "top left";
                // ëª¨ë“  ìš”ì†Œì˜ transform ì œê±° (ë²„íŠ¼ ë“±ì´ ì •í™•í•˜ê²Œ ë Œë”ë§ë˜ë„ë¡)
                const allElements = clonedBody.querySelectorAll("*");
                allElements.forEach((el) => {
                  if (el.style && el.style.transform) {
                    el.style.transform = "none";
                  }
                });

                // í´ë¡ ëœ ë¬¸ì„œì˜ ëª¨ë“  ì´ë¯¸ì§€ë„ ë¡œë“œ ëŒ€ê¸°
                const clonedImages = clonedDoc.querySelectorAll("img");
                clonedImages.forEach((img) => {
                  // base64 ì´ë¯¸ì§€ë‚˜ data URL ì´ë¯¸ì§€ ì²˜ë¦¬
                  if (img.src && img.src.startsWith("data:")) {
                    // data URLì€ ì´ë¯¸ ë¡œë“œëœ ê²ƒìœ¼ë¡œ ê°„ì£¼
                    return;
                  }
                  // ì™¸ë¶€ ì´ë¯¸ì§€ì˜ ê²½ìš° ì›ë³¸ src ìœ ì§€
                  if (img.src && !img.complete) {
                    // ì´ë¯¸ì§€ê°€ ì•„ì§ ë¡œë“œë˜ì§€ ì•Šì€ ê²½ìš° ì›ë³¸ ë¬¸ì„œì—ì„œ ê°€ì ¸ì˜¤ê¸°
                    const originalImg = iframeDoc.querySelector(
                      `img[src="${img.src}"]`
                    );
                    if (originalImg && originalImg.complete) {
                      img.src = originalImg.src;
                    }
                  }
                });
              }
            },
          });

          const imgData = canvas.toDataURL("image/png", 1.0);
          const { jsPDF } = window.jspdf;

          // PDF ìƒì„± - í”½ì…€ì„ mmë¡œ ë³€í™˜ (96 DPI ê¸°ì¤€: 1px = 0.264583mm)
          // scaleì„ ê³ ë ¤í•˜ì—¬ ì‹¤ì œ í¬ê¸° ê³„ì‚°
          const pxToMm = 0.264583;
          const actualWidth = canvas.width / scale;
          const actualHeight = canvas.height / scale;
          const pdfWidth = actualWidth * pxToMm;
          const pdfHeight = actualHeight * pxToMm;

          // ë°©í–¥ì„ ì •í™•í•˜ê²Œ ê²°ì • (ê°€ë¡œ/ì„¸ë¡œ ë¹„ìœ¨ ê¸°ì¤€)
          const isLandscape = actualWidth > actualHeight;

          const pdf = new jsPDF({
            orientation: isLandscape ? "landscape" : "portrait",
            unit: "mm",
            format: [pdfWidth, pdfHeight],
            compress: true,
          });

          // ì´ë¯¸ì§€ë¥¼ PDFì— ì¶”ê°€ (ì •í™•í•œ í¬ê¸°ì™€ ë°©í–¥ ìœ ì§€)
          pdf.addImage(
            imgData,
            "PNG",
            0,
            0,
            pdfWidth,
            pdfHeight,
            undefined,
            "FAST"
          );

          // íŒŒì¼ëª… ìƒì„±
          const pdfFileName =
            uploadedHtmlFileName.replace(/\.(html|htm)$/i, "") + ".pdf";

          // PDF ë‹¤ìš´ë¡œë“œ
          pdf.save(pdfFileName);
          setHtmlStatus("PDF ë‹¤ìš´ë¡œë“œ ì™„ë£Œ!", true);
          btnConvertHtmlToPdf.disabled = false;
        } catch (e) {
          console.error(e);
          setHtmlStatus(
            "PDF ë³€í™˜ ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆì–´ìš”: " +
              (e?.message || "ì•Œ ìˆ˜ ì—†ëŠ” ì˜¤ë¥˜")
          );
          btnConvertHtmlToPdf.disabled = false;
        }
      }

      // HTML file upload events
      ["dragenter", "dragover"].forEach((ev) =>
        htmlDropzone.addEventListener(ev, (e) => {
          e.preventDefault();
          htmlDropzone.classList.add("drop-active");
        })
      );
      ["dragleave", "drop"].forEach((ev) =>
        htmlDropzone.addEventListener(ev, (e) => {
          e.preventDefault();
          htmlDropzone.classList.remove("drop-active");
        })
      );
      htmlDropzone.addEventListener("drop", (e) => {
        const files = e.dataTransfer.files;
        if (files.length > 0) {
          loadHtmlFile(files);
        }
      });

      htmlFileInput.addEventListener("change", (e) => {
        if (e.target.files.length > 0) {
          loadHtmlFile(e.target.files);
        }
      });

      btnClearHtml.addEventListener("click", clearHtmlFile);
      btnConvertHtmlToPdf.addEventListener("click", convertHtmlFileToPdf);

      // init
      updateQualityUI();
      syncGapForKeepSize();
      preview();
    </script>
  </body>
</html>
