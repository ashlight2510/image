<!DOCTYPE html>
<html lang="ko">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <title>ì´ë¯¸ì§€ í•©ì¹˜ê¸° & PDF ë³€í™˜ â€” ë¬´ë£Œ ì›¹íˆ´</title>

    <!-- SEO / OG / Canonical -->
    <meta
      name="description"
      content="ì—¬ëŸ¬ ì¥ì˜ ì´ë¯¸ì§€ë¥¼ í•œ ì¥ìœ¼ë¡œ í•©ì¹˜ê±°ë‚˜(PNG/JPG/WEBP), PDFë¡œ ë³€í™˜/ë‹¤ìš´ë¡œë“œê¹Œì§€ í•œ ë²ˆì—. ë“œë˜ê·¸ ì •ë ¬Â·ì—¬ë°±Â·ê°„ê²©Â·ë°°ì¹˜ ì§€ì›."
    />
    <meta
      name="keywords"
      content="ì´ë¯¸ì§€ í•©ì¹˜ê¸°, ì‚¬ì§„ í•©ì¹˜ê¸°, ì´ë¯¸ì§€ ë³‘í•©, png jpg webp ë³€í™˜, ì´ë¯¸ì§€ pdf ë³€í™˜, jpg pdf, png pdf, ë¬´ë£Œ ì›¹íˆ´"
    />
    <meta name="author" content="FunnyFunny Cloud" />
    <link rel="canonical" href="https://funnyfunny.cloud/" />

    <meta property="og:title" content="ì´ë¯¸ì§€ í•©ì¹˜ê¸° & PDF ë³€í™˜ â€” ë¬´ë£Œ ì›¹íˆ´" />
    <meta
      property="og:description"
      content="ì—¬ëŸ¬ ì¥ ì´ë¯¸ì§€ë¥¼ í•œ ì¥ìœ¼ë¡œ í•©ì¹˜ê³ , PDFë¡œ ë³€í™˜í•´ ë°”ë¡œ ë‹¤ìš´ë¡œë“œ!"
    />
    <!-- OG ì´ë¯¸ì§€ëŠ” ì‚¬ìš© ì„ í˜¸ì— ë§ì¶° dummyimage.com ì‚¬ìš© -->
    <meta
      property="og:image"
      content="https://dummyimage.com/1200x630/0b1220/ffffff&text=Image+Merge+%26+PDF"
    />
    <meta property="og:image:alt" content="Image Merge & PDF" />
    <meta property="og:type" content="website" />
    <meta name="twitter:card" content="summary_large_image" />

    <link
      rel="icon"
      type="image/svg+xml"
      href="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20100%20100'%3E%3Ctext%20y='0.9em'%20font-size='90'%3E%F0%9F%93%8E%3C/text%3E%3C/svg%3E"
    />

    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Drag reorder -->
    <script src="https://cdn.jsdelivr.net/npm/sortablejs@1.15.2/Sortable.min.js"></script>
    <!-- jsPDF -->
    <script src="https://cdn.jsdelivr.net/npm/jspdf@2.5.1/dist/jspdf.umd.min.js"></script>
    <!-- html2canvas for HTML to PDF conversion -->
    <script src="https://cdn.jsdelivr.net/npm/html2canvas@1.4.1/dist/html2canvas.min.js"></script>

    <style>
      :root {
        color-scheme: dark;
      }
      body {
        background: radial-gradient(
            1200px 800px at 20% 10%,
            #1b2a5a33,
            transparent 60%
          ),
          radial-gradient(1200px 800px at 90% 20%, #14532d33, transparent 55%),
          #060913;
      }
      .glass {
        background: rgba(255, 255, 255, 0.06);
        border: 1px solid rgba(255, 255, 255, 0.1);
        backdrop-filter: blur(10px);
      }
      .btn {
        display: inline-flex;
        align-items: center;
        justify-content: center;
        gap: 8px;
        border-radius: 14px;
        padding: 10px 16px;
        font-weight: 700;
        letter-spacing: -0.01em;
        transition: transform 160ms ease, box-shadow 160ms ease,
          filter 160ms ease;
        border: 1px solid transparent;
      }
      .btn:hover {
        transform: translateY(-1px);
      }
      .btn-primary {
        background: radial-gradient(
          120% 120% at 20% 20%,
          #a5f3fc 0%,
          #22d3ee 45%,
          #16a34a 100%
        );
        color: #031123;
        box-shadow: 0 10px 35px rgba(34, 211, 238, 0.25);
      }
      .btn-primary:hover {
        filter: brightness(1.03);
      }
      .btn-ghost {
        background: rgba(255, 255, 255, 0.08);
        border: 1px solid rgba(255, 255, 255, 0.18);
        color: #e5e7eb;
        box-shadow: 0 8px 26px rgba(0, 0, 0, 0.28);
      }
      .btn-ghost:hover {
        background: rgba(255, 255, 255, 0.12);
      }
      .btn-outline {
        background: transparent;
        border: 1.5px solid rgba(34, 211, 238, 0.5);
        color: #befafc;
        box-shadow: 0 0 0 1px rgba(34, 211, 238, 0.18);
      }
      .btn-sm {
        padding: 8px 12px;
        border-radius: 12px;
        font-size: 14px;
      }
      .muted {
        color: rgba(255, 255, 255, 0.75);
      }
      .chip {
        background: rgba(255, 255, 255, 0.08);
        border: 1px solid rgba(255, 255, 255, 0.14);
      }
      .ringy {
        box-shadow: 0 0 0 1px rgba(255, 255, 255, 0.1) inset;
      }
      .drop-active {
        outline: 2px dashed rgba(34, 197, 94, 0.9);
        outline-offset: 6px;
      }
      .thumb {
        aspect-ratio: 4/3;
        background: rgba(255, 255, 255, 0.05);
        border: 1px solid rgba(255, 255, 255, 0.12);
      }
      .small {
        font-size: 12px;
      }
      input[type="range"] {
        accent-color: #22c55e;
      }
      .lang-switch {
        display: inline-flex;
        border-radius: 999px;
        border: 1px solid rgba(255, 255, 255, 0.12);
        background: rgba(8, 12, 22, 0.7);
        padding: 4px;
        gap: 4px;
        font-size: 13px;
      }
      .lang-switch button {
        border-radius: 999px;
        padding: 6px 12px;
        color: rgba(255, 255, 255, 0.7);
        background: transparent;
        border: none;
        cursor: pointer;
      }
      .lang-switch button.active {
        background: rgba(34, 211, 238, 0.2);
        color: #e9fdff;
      }
    </style>
  <script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-1204894220949193"
     crossorigin="anonymous"></script>
    <!-- responsive-base -->
    <style>
      /* responsive-base */
      *, *::before, *::after {
        box-sizing: border-box;
      }
      html {
        -webkit-text-size-adjust: 100%;
      }
      img,
      video,
      canvas,
      svg {
        max-width: 100%;
        height: auto;
      }
      table {
        width: 100%;
      }
      pre,
      code {
        white-space: pre-wrap;
        word-break: break-word;
      }
    </style>
  <style>
    .adsense-block {
      margin: 16px 0;
      display: flex;
      justify-content: center;
    }
    .adsbygoogle {
      display: block;
      margin: 16px auto;
        text-align: center;
}
  </style>
</head>

  <body class="text-white"><header class="max-w-6xl mx-auto px-4 pt-8 pb-4">
      <div
        class="flex flex-col gap-3 sm:flex-row sm:items-end sm:justify-between"
      >
        <div class="flex items-center gap-3">
          <div
            class="w-11 h-11 rounded-2xl glass grid place-items-center text-2xl"
          >
            ğŸ“
          </div>
          <div>
            <h1
              class="text-2xl sm:text-3xl font-extrabold tracking-tight"
              data-i18n="heroTitle"
            >
              ì´ë¯¸ì§€ í•©ì¹˜ê¸° & PDF ë³€í™˜
            </h1>
            <p class="muted mt-1" data-i18n="heroSubtitle">
              ì—¬ëŸ¬ ì¥ ì—…ë¡œë“œ â†’ ë“œë˜ê·¸ ì •ë ¬ â†’ í•œ ì¥ìœ¼ë¡œ í•©ì¹˜ê±°ë‚˜ PDFë¡œ ì €ì¥
            </p>
          </div>
        </div>

        <!-- ë‹¤ë¥¸ ì„œë¹„ìŠ¤ ë³´ê¸°: ê¸°ë³¸ í¬í•¨ -->
        <div class="flex gap-2 items-center">
          <div class="lang-switch" role="tablist" aria-label="Language switcher">
            <button type="button" data-lang="ko" class="active">í•œêµ­ì–´</button>
            <button type="button" data-lang="en">English</button>
          </div>
          <a
            class="btn btn-outline"
            href="https://funnyfunny.cloud/"
            target="_blank"
            rel="noopener"
            ><span data-i18n="viewOtherServices">ë‹¤ë¥¸ ì„œë¹„ìŠ¤ ë³´ê¸° â†—</span></a
          >
        </div>
      </div>
    </header>

    <main class="max-w-6xl mx-auto px-4 pb-14">
      <!-- HTML to PDF Section - ì£¼ìš” ê¸°ëŠ¥ìœ¼ë¡œ ìƒë‹¨ ì´ë™ -->
      <section class="glass rounded-3xl p-5 ringy mb-6">
        <div class="flex items-start justify-between gap-3">
          <div>
            <h2 class="text-lg font-bold" data-i18n="htmlTitle">
              HTML â†’ PDF ë³€í™˜
            </h2>
            <p class="muted small mt-1" data-i18n="htmlSubtitle">
              HTML íŒŒì¼ì„ ì—…ë¡œë“œí•˜ë©´ PDFë¡œ ë³€í™˜í•´ ë‹¤ìš´ë¡œë“œí•  ìˆ˜ ìˆì–´ìš”.
            </p>
          </div>
        </div>

        <div class="mt-4 grid lg:grid-cols-2 gap-4">
          <div>
            <div
              id="htmlDropzone"
              class="rounded-2xl border border-white/15 bg-white/5 p-5"
            >
              <div
                class="flex flex-col sm:flex-row sm:items-center sm:justify-between gap-3"
              >
                <div>
                  <div class="font-semibold text-white" data-i18n="htmlDropTitle">
                    HTML íŒŒì¼ ë“œë˜ê·¸&ë“œë¡­
                  </div>
                  <div class="muted small mt-1" data-i18n="htmlDropHint">
                    HTMLê³¼ ì´ë¯¸ì§€ íŒŒì¼ì„ í•¨ê»˜ ì„ íƒí•˜ì„¸ìš”.
                  </div>
                </div>
                <label
                  class="btn btn-primary relative overflow-hidden cursor-pointer shadow-lg shadow-cyan-500/15"
                >
                  <input
                    id="htmlFileInput"
                    type="file"
                    class="absolute inset-0 opacity-0 cursor-pointer"
                    accept=".html,.htm,text/html,image/*"
                    multiple
                    aria-label="HTML ë° ì´ë¯¸ì§€ íŒŒì¼ ì„ íƒ"
                    data-i18n-aria="htmlFileAria"
                  />
                  <span class="font-semibold" data-i18n="btnSelectFiles">
                    íŒŒì¼ ì„ íƒ
                  </span>
                </label>
              </div>
            </div>

            <div class="mt-4">
              <div class="flex items-center justify-between mb-2">
                <h3 class="font-bold" data-i18n="htmlUploadedTitle">
                  ì—…ë¡œë“œëœ HTML
                </h3>
                <button
                  id="btnClearHtml"
                  class="btn btn-ghost btn-sm"
                  type="button"
                  style="display: none"
                  data-i18n="btnClear"
                >
                  ë¹„ìš°ê¸°
                </button>
              </div>
              <div id="htmlFileName" class="muted small"></div>
            </div>

            <div class="mt-4 chip rounded-2xl p-4">
              <div class="font-semibold" data-i18n="htmlViewportTitle">
                PDF ë Œë”ë§ í­
              </div>
              <div class="muted small mt-1" data-i18n="htmlViewportHint">
                ë¬¸ì„œ ì„±í–¥ì— ë§ê²Œ PC/ëª¨ë°”ì¼ í­ì„ ì„ íƒí•˜ì„¸ìš”.
              </div>
              <select
                id="htmlViewport"
                class="mt-2 w-full rounded-xl bg-black/30 border border-white/15 px-3 py-2"
              >
                <option value="desktop" selected data-i18n="viewportDesktop">
                  ë°ìŠ¤í¬í†±(1280px)
                </option>
                <option value="wide" data-i18n="viewportWide">
                  ì™€ì´ë“œ(1600px)
                </option>
                <option value="auto" data-i18n="viewportAuto">
                  ë¬¸ì„œ ìë™
                </option>
                <option value="mobile" data-i18n="viewportMobile">
                  ëª¨ë°”ì¼(390px)
                </option>
                <option value="custom" data-i18n="viewportCustom">
                  ì§ì ‘ ì…ë ¥
                </option>
              </select>
              <div id="htmlCustomWrap" class="mt-3" style="display: none">
                <div class="muted small" data-i18n="viewportCustomLabel">
                  ì§ì ‘ ì…ë ¥(px)
                </div>
                <input
                  id="htmlCustomWidth"
                  type="number"
                  min="320"
                  max="3840"
                  value="1280"
                  class="mt-1 w-full rounded-xl bg-black/30 border border-white/15 px-3 py-2"
                />
              </div>
            </div>

            <div class="mt-4">
              <button
                id="btnConvertHtmlToPdf"
                class="btn btn-primary w-full shadow-lg shadow-emerald-400/25"
                type="button"
                disabled
                data-i18n="btnConvertHtml"
              >
                PDFë¡œ ë³€í™˜í•˜ê¸°
              </button>
              <div id="htmlStatus" class="mt-2 muted small"></div>
            </div>
          </div>

          <div>
            <div class="chip rounded-2xl p-4">
              <div class="font-semibold mb-2" data-i18n="previewTitle">
                ë¯¸ë¦¬ë³´ê¸°
              </div>
              <div
                id="htmlPreview"
                class="rounded-xl border border-white/10 bg-black/30 p-3"
                style="min-height: 300px; max-height: 600px; overflow: auto; position: relative;"
              >
                <div
                  class="muted small text-center py-8"
                  data-i18n="htmlPreviewEmpty"
                >
                  HTML íŒŒì¼ì„ ì—…ë¡œë“œí•˜ë©´ ì—¬ê¸°ì— ë¯¸ë¦¬ë³´ê¸°ê°€ í‘œì‹œë©ë‹ˆë‹¤.
                </div>
              </div>
            </div>
          </div>
        </div>
      </section>

      <section class="grid lg:grid-cols-2 gap-4">
        <!-- Upload -->
        <div class="glass rounded-3xl p-5 ringy">
          <div class="flex items-start justify-between gap-3">
            <div>
              <h2 class="text-lg font-bold" data-i18n="step1Title">
                1) ì´ë¯¸ì§€ ë„£ê¸°
              </h2>
              <p class="muted small mt-1" data-i18n="step1Subtitle">
                PNG/JPG/WEBP/GIF(ì²« í”„ë ˆì„) ë“± ë¸Œë¼ìš°ì €ê°€ ì½ëŠ” ì´ë¯¸ì§€ë¥¼
                ì§€ì›í•´ìš”.
              </p>
            </div>
            <div class="flex gap-2">
              <button
                id="btnClear"
                class="btn btn-ghost btn-sm"
                type="button"
                data-i18n="btnClearAll"
              >
                ì „ì²´ ë¹„ìš°ê¸°
              </button>
            </div>
          </div>

          <div
            id="dropzone"
            class="mt-4 rounded-2xl border border-white/15 bg-white/5 p-5"
          >
            <div
              class="flex flex-col sm:flex-row sm:items-center sm:justify-between gap-3"
            >
              <div>
                <div class="font-semibold text-white" data-i18n="dropzoneTitle">
                  ì—¬ê¸°ì— ë“œë˜ê·¸&ë“œë¡­
                </div>
                <div class="muted small mt-1" data-i18n="dropzoneHint">
                  ë˜ëŠ” íŒŒì¼ ì„ íƒ ë²„íŠ¼ì„ ëˆŒëŸ¬ì£¼ì„¸ìš”.
                </div>
              </div>
              <label
                class="btn btn-primary relative overflow-hidden cursor-pointer shadow-lg shadow-cyan-500/15"
              >
                <input
                  id="fileInput"
                  type="file"
                  class="absolute inset-0 opacity-0 cursor-pointer"
                  accept="image/*"
                  multiple
                  aria-label="ì´ë¯¸ì§€ íŒŒì¼ ì„ íƒ"
                  data-i18n-aria="imageFileAria"
                />
                <span class="font-semibold" data-i18n="btnSelectImages">
                  íŒŒì¼ ì„ íƒ
                </span>
              </label>
            </div>
            <div class="mt-3 muted small" data-i18n-html="dragTip">
              ğŸ’¡ íŒ: ë¦¬ìŠ¤íŠ¸ì—ì„œ ì¸ë„¤ì¼ì„
              <span class="text-white font-semibold">ë“œë˜ê·¸</span>í•´ì„œ ìˆœì„œë¥¼
              ë°”ê¿€ ìˆ˜ ìˆì–´ìš”.
            </div>
          </div>

          <div class="mt-4">
            <div class="flex items-center justify-between">
              <h3 class="font-bold" data-i18n="uploadListTitle">
                ì—…ë¡œë“œ ëª©ë¡
              </h3>
              <div class="muted small">
                <span id="count">0</span><span data-i18n="unitImages">ì¥</span>
              </div>
            </div>

            <div id="list" class="mt-3 grid sm:grid-cols-2 gap-3">
              <!-- items -->
            </div>

            <div
              id="emptyHint"
              class="mt-4 rounded-2xl border border-white/10 bg-white/5 p-4 muted small text-center"
              data-i18n-html="emptyHint"
            >
              ğŸ“· ì•„ì§ ì´ë¯¸ì§€ê°€ ì—†ì–´ìš”.<br />
              ìœ„ì—ì„œ ì—…ë¡œë“œí•˜ê±°ë‚˜ íŒŒì¼ ì„ íƒ ë²„íŠ¼ì„ ëˆŒëŸ¬ë³´ì„¸ìš”.
            </div>
          </div>
        </div>

        <!-- Options -->
        <div class="glass rounded-3xl p-5 ringy">
          <h2 class="text-lg font-bold" data-i18n="step2Title">
            2) ì¶œë ¥ ì„¤ì •
          </h2>
          <p class="muted small mt-1" data-i18n="step2Subtitle">
            í•œ ì¥ ì´ë¯¸ì§€ë¡œ í•©ì¹˜ê¸°(ì„¸ë¡œ/ê°€ë¡œ/ê·¸ë¦¬ë“œ) ë˜ëŠ” PDF(í˜ì´ì§€ë³„/ê·¸ë¦¬ë“œ)ë¡œ
            ë³€í™˜.
          </p>

          <div class="mt-5 grid gap-4">
            <div class="grid sm:grid-cols-2 gap-3">
              <div class="chip rounded-2xl p-4">
                <div class="font-semibold" data-i18n="outputTypeLabel">
                  ì¶œë ¥ íƒ€ì…
                </div>
                <select
                  id="outType"
                  class="mt-2 w-full rounded-xl bg-black/30 border border-white/15 px-3 py-2"
                >
                  <option value="image" data-i18n="outTypeImage">
                    í•©ì¹œ ì´ë¯¸ì§€ë¡œ ë‹¤ìš´ë¡œë“œ
                  </option>
                  <option value="pdf" data-i18n="outTypePdf">
                    PDFë¡œ ë‹¤ìš´ë¡œë“œ
                  </option>
                  <option value="zip" data-i18n="outTypeZip">
                    ê°œë³„ ë³€í™˜ ZIP(ì´ë¯¸ì§€ í¬ë§·ë§Œ)
                  </option>
                </select>
                <div class="muted small mt-2" data-i18n="zipHint">
                  ZIPì€ ê°œë³„ ì´ë¯¸ì§€ë¥¼ ì„ íƒí•œ í¬ë§·ìœ¼ë¡œ ë³€í™˜í•´ ë¬¶ì–´ì¤˜ìš”.
                </div>
              </div>

              <div class="chip rounded-2xl p-4">
                <div class="font-semibold" data-i18n="imageFormatLabel">
                  ì´ë¯¸ì§€ í¬ë§·
                </div>
                <select
                  id="imgFormat"
                  class="mt-2 w-full rounded-xl bg-black/30 border border-white/15 px-3 py-2"
                >
                  <option value="image/png">PNG</option>
                  <option value="image/jpeg">JPG</option>
                  <option value="image/webp">WEBP</option>
                </select>
                <div id="qualityWrap" class="mt-3">
                  <div class="flex items-center justify-between">
                    <div class="muted small" data-i18n="qualityLabel">
                      JPG/WEBP í’ˆì§ˆ
                    </div>
                    <div class="small"><span id="qLabel">0.90</span></div>
                  </div>
                  <input
                    id="quality"
                    type="range"
                    min="0.4"
                    max="1"
                    step="0.02"
                    value="0.9"
                    class="w-full mt-2"
                  />
                </div>
              </div>
            </div>

            <div class="chip rounded-2xl p-4">
              <div class="flex items-start justify-between gap-3">
                <div>
                  <div class="font-semibold" data-i18n="layoutTitle">
                    í•©ì¹˜ê¸° ë ˆì´ì•„ì›ƒ
                  </div>
                  <div class="muted small mt-1" data-i18n="layoutHint">
                    ì¶œë ¥ íƒ€ì…ì´ â€œí•©ì¹œ ì´ë¯¸ì§€â€ì¼ ë•Œ ì ìš©
                  </div>
                </div>
                <div class="small text-white/80" data-i18n="layoutNote">
                  ìº”ë²„ìŠ¤ ê¸°ë°˜
                </div>
              </div>

              <div class="mt-3 grid sm:grid-cols-3 gap-2">
                <label
                  class="flex items-center gap-2 rounded-xl px-3 py-2 bg-white/5 border border-white/10 cursor-pointer"
                >
                  <input
                    type="radio"
                    name="layout"
                    value="vertical"
                    class="accent-green-500"
                    checked
                  />
                  <span data-i18n="layoutVertical">ì„¸ë¡œ</span>
                </label>
                <label
                  class="flex items-center gap-2 rounded-xl px-3 py-2 bg-white/5 border border-white/10 cursor-pointer"
                >
                  <input
                    type="radio"
                    name="layout"
                    value="horizontal"
                    class="accent-green-500"
                  />
                  <span data-i18n="layoutHorizontal">ê°€ë¡œ</span>
                </label>
                <label
                  class="flex items-center gap-2 rounded-xl px-3 py-2 bg-white/5 border border-white/10 cursor-pointer"
                >
                  <input
                    type="radio"
                    name="layout"
                    value="grid"
                    class="accent-green-500"
                  />
                  <span data-i18n="layoutGrid">ê·¸ë¦¬ë“œ</span>
                </label>
              </div>

              <label
                class="mt-3 flex items-center gap-2 rounded-xl px-3 py-2 bg-white/5 border border-white/10 cursor-pointer"
              >
                <input id="keepSize" type="checkbox" class="accent-green-500" />
                <div>
                  <div data-i18n="keepSizeTitle">ì›ë³¸ í¬ê¸° ê·¸ëŒ€ë¡œ ë¶™ì´ê¸°</div>
                  <div class="muted small" data-i18n="keepSizeHint">
                    ë¦¬ì‚¬ì´ì¦ˆ ì—†ì´ ê°„ê²© 0ìœ¼ë¡œ ì„¸ë¡œ/ê°€ë¡œ í•©ì¹˜ê¸°
                  </div>
                </div>
              </label>

              <div class="mt-4 grid sm:grid-cols-3 gap-3">
                <div>
                  <div class="muted small" data-i18n="gapLabel">ê°„ê²©(px)</div>
                  <input
                    id="gap"
                    type="number"
                    min="0"
                    value="16"
                    class="mt-1 w-full rounded-xl bg-black/30 border border-white/15 px-3 py-2"
                  />
                </div>
                <div>
                  <div class="muted small" data-i18n="bgLabel">ë°°ê²½</div>
                  <select
                    id="bg"
                    class="mt-1 w-full rounded-xl bg-black/30 border border-white/15 px-3 py-2"
                  >
                    <option value="#0b1220" data-i18n="bgDark">ì–´ë‘ì›€</option>
                    <option value="#ffffff" data-i18n="bgLight">í°ìƒ‰</option>
                    <option value="transparent" data-i18n="bgTransparent">
                      íˆ¬ëª…(PNGë§Œ)
                    </option>
                  </select>
                </div>
                <div>
                  <div class="muted small" data-i18n="gridColsLabel">
                    ê·¸ë¦¬ë“œ ì—´
                  </div>
                  <input
                    id="cols"
                    type="number"
                    min="1"
                    max="8"
                    value="2"
                    class="mt-1 w-full rounded-xl bg-black/30 border border-white/15 px-3 py-2"
                  />
                </div>
              </div>

              <div class="mt-3 muted small" data-i18n-html="bgTip">
                ğŸ’¡ íˆ¬ëª… ë°°ê²½ì€ <span class="text-white font-semibold">PNG</span>ì¼
                ë•Œë§Œ ì˜ë¯¸ê°€ ìˆì–´ìš”.
              </div>
            </div>

            <div class="chip rounded-2xl p-4">
              <div class="flex items-start justify-between gap-3">
                <div>
                  <div class="font-semibold" data-i18n="pdfTitle">PDF ì„¤ì •</div>
                  <div class="muted small mt-1" data-i18n="pdfHint">
                    ì¶œë ¥ íƒ€ì…ì´ PDFì¼ ë•Œ ì ìš©
                  </div>
                </div>
                <div class="small text-white/80" data-i18n="pdfNote">
                  í˜ì´ì§€ ë‹¨ìœ„
                </div>
              </div>

              <div class="mt-3 grid sm:grid-cols-3 gap-3">
                <div>
                  <div class="muted small" data-i18n="pdfPaperLabel">
                    ìš©ì§€
                  </div>
                  <select
                    id="pdfSize"
                    class="mt-1 w-full rounded-xl bg-black/30 border border-white/15 px-3 py-2"
                  >
                    <option value="a4">A4</option>
                    <option value="letter">Letter</option>
                    <option value="auto" data-i18n="pdfPaperAuto">
                      ì´ë¯¸ì§€ì— ë§ì¶¤(ê¶Œì¥)
                    </option>
                  </select>
                </div>
                <div>
                  <div class="muted small" data-i18n="pdfOrientationLabel">
                    ë°©í–¥
                  </div>
                  <select
                    id="pdfOri"
                    class="mt-1 w-full rounded-xl bg-black/30 border border-white/15 px-3 py-2"
                  >
                    <option value="portrait" data-i18n="orientationPortrait">
                      ì„¸ë¡œ
                    </option>
                    <option value="landscape" data-i18n="orientationLandscape">
                      ê°€ë¡œ
                    </option>
                    <option value="auto" data-i18n="orientationAuto">
                      ìë™
                    </option>
                  </select>
                </div>
                <div>
                  <div class="muted small" data-i18n="pdfMarginLabel">
                    ì—¬ë°±(px)
                  </div>
                  <input
                    id="pdfMargin"
                    type="number"
                    min="0"
                    value="24"
                    class="mt-1 w-full rounded-xl bg-black/30 border border-white/15 px-3 py-2"
                  />
                </div>
              </div>

              <div class="mt-3 grid sm:grid-cols-2 gap-2">
                <label
                  class="flex items-center gap-2 rounded-xl px-3 py-2 bg-white/5 border border-white/10 cursor-pointer"
                >
                  <input
                    id="pdfOnePerPage"
                    type="radio"
                    name="pdfMode"
                    value="one"
                    class="accent-green-500"
                    checked
                  />
                  <span data-i18n="pdfOnePerPage">1í˜ì´ì§€ì— 1ì¥</span>
                </label>
                <label
                  class="flex items-center gap-2 rounded-xl px-3 py-2 bg-white/5 border border-white/10 cursor-pointer"
                >
                  <input
                    id="pdfGrid"
                    type="radio"
                    name="pdfMode"
                    value="grid"
                    class="accent-green-500"
                  />
                  <span data-i18n="pdfGrid">í•œ í˜ì´ì§€ ê·¸ë¦¬ë“œ</span>
                </label>
              </div>

              <div class="mt-3 muted small" data-i18n-html="pdfTip">
                ğŸ’¡ "ì´ë¯¸ì§€ì— ë§ì¶¤"ì€ ì´ë¯¸ì§€ í¬ê¸°ì— ë§ì¶° PDF í˜ì´ì§€ë¥¼ ì¡ì•„ì„œ
                <span class="text-white font-semibold">ì˜ë¦¼ì„ ìµœì†Œí™”</span>í•´ìš”.
              </div>
            </div>
          </div>

          <div class="mt-5 flex flex-col sm:flex-row gap-2">
            <button
              id="btnPreview"
              class="btn btn-ghost btn-sm w-full sm:w-auto"
              type="button"
              data-i18n="btnPreview"
            >
              ë¯¸ë¦¬ë³´ê¸°
            </button>
            <button
              id="btnMake"
              class="btn btn-primary w-full sm:flex-1 shadow-lg shadow-emerald-400/25"
              type="button"
              data-i18n="btnMakeDownload"
            >
              ë‹¤ìš´ë¡œë“œ ë§Œë“¤ê¸°
            </button>
          </div>

          <div id="status" class="mt-4 muted small"></div>
        </div>
      </section>

      <!-- Preview -->
      <section class="mt-4 glass rounded-3xl p-5 ringy">
        <div class="flex items-start justify-between gap-3">
          <div>
            <h2 class="text-lg font-bold" data-i18n="step3Title">
              3) ê²°ê³¼ ë¯¸ë¦¬ë³´ê¸°
            </h2>
            <p class="muted small mt-1" data-i18n="step3Subtitle">
              í•©ì¹œ ì´ë¯¸ì§€ëŠ” ì•„ë˜ ìº”ë²„ìŠ¤ë¡œ, PDFëŠ” í˜ì´ì§€ ìˆ˜/ìš©ëŸ‰ ì •ë³´ë¡œ ë¯¸ë¦¬
              í™•ì¸í•´ìš”.
            </p>
          </div>
          <a
            class="btn btn-ghost btn-sm"
            href="#top"
            onclick="window.scrollTo({top:0,behavior:'smooth'})"
            data-i18n="btnTop"
            >ìœ„ë¡œ</a
          >
        </div>

        <div class="mt-4 grid lg:grid-cols-3 gap-4">
          <div class="lg:col-span-2">
            <div class="rounded-2xl border border-white/10 bg-black/30 p-3">
              <canvas
                id="canvas"
                class="w-full rounded-xl bg-black/40"
              ></canvas>
            </div>
            <div class="muted small mt-2" data-i18n="canvasTip">
              âš¡ ìº”ë²„ìŠ¤ëŠ” ë¸Œë¼ìš°ì € ì„±ëŠ¥ì— ë”°ë¼ í° ì´ë¯¸ì§€ì—ì„œ ì‹œê°„ì´ ê±¸ë¦´ ìˆ˜ ìˆì–´ìš”.
            </div>
          </div>

          <div class="chip rounded-2xl p-4">
            <div class="font-semibold" data-i18n="infoTitle">ì •ë³´</div>
            <div class="mt-3 space-y-2 small">
              <div class="flex justify-between">
                <span class="muted" data-i18n="infoTotal">ì´ ì´ë¯¸ì§€</span
                ><span id="infoCount">0</span>
              </div>
              <div class="flex justify-between">
                <span class="muted" data-i18n="infoSize">ì˜ˆìƒ í¬ê¸°</span
                ><span id="infoSize">-</span>
              </div>
              <div class="flex justify-between">
                <span class="muted" data-i18n="infoPages">PDF í˜ì´ì§€</span
                ><span id="infoPages">-</span>
              </div>
              <div class="flex justify-between">
                <span class="muted" data-i18n="infoState">ìƒíƒœ</span
                ><span id="infoState" data-i18n="stateIdle">ëŒ€ê¸°</span>
              </div>
            </div>

            <div
              class="mt-4 rounded-xl border border-white/10 bg-white/5 p-3 muted small"
              data-i18n-html="privacyNote"
            >
              ğŸ”’ ì´ í˜ì´ì§€ëŠ” ê¸°ë³¸ì ìœ¼ë¡œ
              <b class="text-white">ë¸Œë¼ìš°ì € ì•ˆì—ì„œ</b> ì²˜ë¦¬í•©ë‹ˆë‹¤.<br />
              (ëŒ€ìš©ëŸ‰/ì´ˆê³ í•´ìƒë„ëŠ” ëŠë¦´ ìˆ˜ ìˆì–´ìš”.)
            </div>
          </div>
        </div>
      </section>


      <footer class="mt-6 text-center muted small" data-i18n="footerNote">
        Â© FunnyFunny Cloud â€” ë¹ ë¥´ê³  ê°€ë²¼ìš´ ì‹¤í—˜ì  ì›¹ì„œë¹„ìŠ¤
      </footer>
    </main>

    <!-- ZIP support (optional): JSZip via CDN -->
    <script src="https://cdn.jsdelivr.net/npm/jszip@3.10.1/dist/jszip.min.js"></script>

    <script>
      const translations = {
        ko: {
          metaTitle: "ì´ë¯¸ì§€ í•©ì¹˜ê¸° & PDF ë³€í™˜ â€” ë¬´ë£Œ ì›¹íˆ´",
          metaDescription:
            "ì—¬ëŸ¬ ì¥ì˜ ì´ë¯¸ì§€ë¥¼ í•œ ì¥ìœ¼ë¡œ í•©ì¹˜ê±°ë‚˜(PNG/JPG/WEBP), PDFë¡œ ë³€í™˜/ë‹¤ìš´ë¡œë“œê¹Œì§€ í•œ ë²ˆì—. ë“œë˜ê·¸ ì •ë ¬Â·ì—¬ë°±Â·ê°„ê²©Â·ë°°ì¹˜ ì§€ì›.",
          metaOgTitle: "ì´ë¯¸ì§€ í•©ì¹˜ê¸° & PDF ë³€í™˜ â€” ë¬´ë£Œ ì›¹íˆ´",
          metaOgDescription:
            "ì—¬ëŸ¬ ì¥ ì´ë¯¸ì§€ë¥¼ í•œ ì¥ìœ¼ë¡œ í•©ì¹˜ê³ , PDFë¡œ ë³€í™˜í•´ ë°”ë¡œ ë‹¤ìš´ë¡œë“œ!",
          heroTitle: "ì´ë¯¸ì§€ í•©ì¹˜ê¸° & PDF ë³€í™˜",
          heroSubtitle:
            "ì—¬ëŸ¬ ì¥ ì—…ë¡œë“œ â†’ ë“œë˜ê·¸ ì •ë ¬ â†’ í•œ ì¥ìœ¼ë¡œ í•©ì¹˜ê±°ë‚˜ PDFë¡œ ì €ì¥",
          viewOtherServices: "ë‹¤ë¥¸ ì„œë¹„ìŠ¤ ë³´ê¸° â†—",
          htmlTitle: "HTML â†’ PDF ë³€í™˜",
          htmlSubtitle:
            "HTML íŒŒì¼ì„ ì—…ë¡œë“œí•˜ë©´ PDFë¡œ ë³€í™˜í•´ ë‹¤ìš´ë¡œë“œí•  ìˆ˜ ìˆì–´ìš”.",
          htmlDropTitle: "HTML íŒŒì¼ ë“œë˜ê·¸&ë“œë¡­",
          htmlDropHint: "HTMLê³¼ ì´ë¯¸ì§€ íŒŒì¼ì„ í•¨ê»˜ ì„ íƒí•˜ì„¸ìš”.",
          htmlFileAria: "HTML ë° ì´ë¯¸ì§€ íŒŒì¼ ì„ íƒ",
          btnSelectFiles: "íŒŒì¼ ì„ íƒ",
          htmlUploadedTitle: "ì—…ë¡œë“œëœ HTML",
          btnClear: "ë¹„ìš°ê¸°",
          htmlViewportTitle: "PDF ë Œë”ë§ í­",
          htmlViewportHint: "ë¬¸ì„œ ì„±í–¥ì— ë§ê²Œ PC/ëª¨ë°”ì¼ í­ì„ ì„ íƒí•˜ì„¸ìš”.",
          viewportDesktop: "ë°ìŠ¤í¬í†±(1280px)",
          viewportWide: "ì™€ì´ë“œ(1600px)",
          viewportAuto: "ë¬¸ì„œ ìë™",
          viewportMobile: "ëª¨ë°”ì¼(390px)",
          viewportCustom: "ì§ì ‘ ì…ë ¥",
          viewportCustomLabel: "ì§ì ‘ ì…ë ¥(px)",
          btnConvertHtml: "PDFë¡œ ë³€í™˜í•˜ê¸°",
          previewTitle: "ë¯¸ë¦¬ë³´ê¸°",
          htmlPreviewEmpty:
            "HTML íŒŒì¼ì„ ì—…ë¡œë“œí•˜ë©´ ì—¬ê¸°ì— ë¯¸ë¦¬ë³´ê¸°ê°€ í‘œì‹œë©ë‹ˆë‹¤.",
          step1Title: "1) ì´ë¯¸ì§€ ë„£ê¸°",
          step1Subtitle:
            "PNG/JPG/WEBP/GIF(ì²« í”„ë ˆì„) ë“± ë¸Œë¼ìš°ì €ê°€ ì½ëŠ” ì´ë¯¸ì§€ë¥¼ ì§€ì›í•´ìš”.",
          btnClearAll: "ì „ì²´ ë¹„ìš°ê¸°",
          dropzoneTitle: "ì—¬ê¸°ì— ë“œë˜ê·¸&ë“œë¡­",
          dropzoneHint: "ë˜ëŠ” íŒŒì¼ ì„ íƒ ë²„íŠ¼ì„ ëˆŒëŸ¬ì£¼ì„¸ìš”.",
          imageFileAria: "ì´ë¯¸ì§€ íŒŒì¼ ì„ íƒ",
          btnSelectImages: "íŒŒì¼ ì„ íƒ",
          dragTip:
            "ğŸ’¡ íŒ: ë¦¬ìŠ¤íŠ¸ì—ì„œ ì¸ë„¤ì¼ì„ <span class=\"text-white font-semibold\">ë“œë˜ê·¸</span>í•´ì„œ ìˆœì„œë¥¼ ë°”ê¿€ ìˆ˜ ìˆì–´ìš”.",
          uploadListTitle: "ì—…ë¡œë“œ ëª©ë¡",
          unitImages: "ì¥",
          emptyHint:
            "ğŸ“· ì•„ì§ ì´ë¯¸ì§€ê°€ ì—†ì–´ìš”.<br />ìœ„ì—ì„œ ì—…ë¡œë“œí•˜ê±°ë‚˜ íŒŒì¼ ì„ íƒ ë²„íŠ¼ì„ ëˆŒëŸ¬ë³´ì„¸ìš”.",
          step2Title: "2) ì¶œë ¥ ì„¤ì •",
          step2Subtitle:
            "í•œ ì¥ ì´ë¯¸ì§€ë¡œ í•©ì¹˜ê¸°(ì„¸ë¡œ/ê°€ë¡œ/ê·¸ë¦¬ë“œ) ë˜ëŠ” PDF(í˜ì´ì§€ë³„/ê·¸ë¦¬ë“œ)ë¡œ ë³€í™˜.",
          outputTypeLabel: "ì¶œë ¥ íƒ€ì…",
          outTypeImage: "í•©ì¹œ ì´ë¯¸ì§€ë¡œ ë‹¤ìš´ë¡œë“œ",
          outTypePdf: "PDFë¡œ ë‹¤ìš´ë¡œë“œ",
          outTypeZip: "ê°œë³„ ë³€í™˜ ZIP(ì´ë¯¸ì§€ í¬ë§·ë§Œ)",
          zipHint: "ZIPì€ ê°œë³„ ì´ë¯¸ì§€ë¥¼ ì„ íƒí•œ í¬ë§·ìœ¼ë¡œ ë³€í™˜í•´ ë¬¶ì–´ì¤˜ìš”.",
          imageFormatLabel: "ì´ë¯¸ì§€ í¬ë§·",
          qualityLabel: "JPG/WEBP í’ˆì§ˆ",
          layoutTitle: "í•©ì¹˜ê¸° ë ˆì´ì•„ì›ƒ",
          layoutHint: "ì¶œë ¥ íƒ€ì…ì´ â€œí•©ì¹œ ì´ë¯¸ì§€â€ì¼ ë•Œ ì ìš©",
          layoutNote: "ìº”ë²„ìŠ¤ ê¸°ë°˜",
          layoutVertical: "ì„¸ë¡œ",
          layoutHorizontal: "ê°€ë¡œ",
          layoutGrid: "ê·¸ë¦¬ë“œ",
          keepSizeTitle: "ì›ë³¸ í¬ê¸° ê·¸ëŒ€ë¡œ ë¶™ì´ê¸°",
          keepSizeHint: "ë¦¬ì‚¬ì´ì¦ˆ ì—†ì´ ê°„ê²© 0ìœ¼ë¡œ ì„¸ë¡œ/ê°€ë¡œ í•©ì¹˜ê¸°",
          gapLabel: "ê°„ê²©(px)",
          bgLabel: "ë°°ê²½",
          bgDark: "ì–´ë‘ì›€",
          bgLight: "í°ìƒ‰",
          bgTransparent: "íˆ¬ëª…(PNGë§Œ)",
          gridColsLabel: "ê·¸ë¦¬ë“œ ì—´",
          bgTip:
            "ğŸ’¡ íˆ¬ëª… ë°°ê²½ì€ <span class=\"text-white font-semibold\">PNG</span>ì¼ ë•Œë§Œ ì˜ë¯¸ê°€ ìˆì–´ìš”.",
          pdfTitle: "PDF ì„¤ì •",
          pdfHint: "ì¶œë ¥ íƒ€ì…ì´ PDFì¼ ë•Œ ì ìš©",
          pdfNote: "í˜ì´ì§€ ë‹¨ìœ„",
          pdfPaperLabel: "ìš©ì§€",
          pdfPaperAuto: "ì´ë¯¸ì§€ì— ë§ì¶¤(ê¶Œì¥)",
          pdfOrientationLabel: "ë°©í–¥",
          orientationPortrait: "ì„¸ë¡œ",
          orientationLandscape: "ê°€ë¡œ",
          orientationAuto: "ìë™",
          pdfMarginLabel: "ì—¬ë°±(px)",
          pdfOnePerPage: "1í˜ì´ì§€ì— 1ì¥",
          pdfGrid: "í•œ í˜ì´ì§€ ê·¸ë¦¬ë“œ",
          pdfTip:
            "ğŸ’¡ \"ì´ë¯¸ì§€ì— ë§ì¶¤\"ì€ ì´ë¯¸ì§€ í¬ê¸°ì— ë§ì¶° PDF í˜ì´ì§€ë¥¼ ì¡ì•„ì„œ <span class=\"text-white font-semibold\">ì˜ë¦¼ì„ ìµœì†Œí™”</span>í•´ìš”.",
          btnPreview: "ë¯¸ë¦¬ë³´ê¸°",
          btnMakeDownload: "ë‹¤ìš´ë¡œë“œ ë§Œë“¤ê¸°",
          step3Title: "3) ê²°ê³¼ ë¯¸ë¦¬ë³´ê¸°",
          step3Subtitle:
            "í•©ì¹œ ì´ë¯¸ì§€ëŠ” ì•„ë˜ ìº”ë²„ìŠ¤ë¡œ, PDFëŠ” í˜ì´ì§€ ìˆ˜/ìš©ëŸ‰ ì •ë³´ë¡œ ë¯¸ë¦¬ í™•ì¸í•´ìš”.",
          btnTop: "ìœ„ë¡œ",
          canvasTip:
            "âš¡ ìº”ë²„ìŠ¤ëŠ” ë¸Œë¼ìš°ì € ì„±ëŠ¥ì— ë”°ë¼ í° ì´ë¯¸ì§€ì—ì„œ ì‹œê°„ì´ ê±¸ë¦´ ìˆ˜ ìˆì–´ìš”.",
          infoTitle: "ì •ë³´",
          infoTotal: "ì´ ì´ë¯¸ì§€",
          infoSize: "ì˜ˆìƒ í¬ê¸°",
          infoPages: "PDF í˜ì´ì§€",
          infoState: "ìƒíƒœ",
          stateIdle: "ëŒ€ê¸°",
          privacyNote:
            "ğŸ”’ ì´ í˜ì´ì§€ëŠ” ê¸°ë³¸ì ìœ¼ë¡œ <b class=\"text-white\">ë¸Œë¼ìš°ì € ì•ˆì—ì„œ</b> ì²˜ë¦¬í•©ë‹ˆë‹¤.<br />(ëŒ€ìš©ëŸ‰/ì´ˆê³ í•´ìƒë„ëŠ” ëŠë¦´ ìˆ˜ ìˆì–´ìš”.)",
          footerNote: "Â© FunnyFunny Cloud â€” ë¹ ë¥´ê³  ê°€ë²¼ìš´ ì‹¤í—˜ì  ì›¹ì„œë¹„ìŠ¤",
          statusLoading: "ë¡œë”©",
          statusPreview: "ë¯¸ë¦¬ë³´ê¸°",
          statusError: "ì˜¤ë¥˜",
          statusBuilding: "ìƒì„±ì¤‘",
          errorImageRead: "ì´ë¯¸ì§€ë¥¼ ì½ì„ ìˆ˜ ì—†ì–´ìš”.",
          errorOnlyImages: "ì´ë¯¸ì§€ íŒŒì¼ë§Œ ë„£ì„ ìˆ˜ ìˆì–´ìš”.",
          statusLoadingImages: "ì´ë¯¸ì§€ {count}ì¥ ë¶ˆëŸ¬ì˜¤ëŠ” ì¤‘...",
          statusUploadDone: "ì—…ë¡œë“œ ì™„ë£Œ!",
          statusPreviewError:
            "ë¯¸ë¦¬ë³´ê¸° ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆì–´ìš”. ì„¤ì •ì„ ë‹¤ì‹œ í™•ì¸í•´ì£¼ì„¸ìš”.",
          statusNeedImages: "ì´ë¯¸ì§€ë¥¼ ë¨¼ì € ì¶”ê°€í•´ì£¼ì„¸ìš”.",
          statusBuildingNow: "ë§Œë“œëŠ” ì¤‘... (í° ì´ë¯¸ì§€ëŠ” ì‹œê°„ì´ ê±¸ë¦´ ìˆ˜ ìˆì–´ìš”)",
          statusMergedDone: "í•©ì¹œ ì´ë¯¸ì§€ë¥¼ ë‹¤ìš´ë¡œë“œí–ˆì–´ìš”!",
          statusPdfDone: "PDF ë‹¤ìš´ë¡œë“œ ì™„ë£Œ!",
          statusZipDone: "ZIP ë‹¤ìš´ë¡œë“œ ì™„ë£Œ!",
          statusZipUnsupported: "ZIPì€ ì´ë¯¸ì§€ í¬ë§·(PNG/JPG/WEBP)ì—ì„œë§Œ ì§€ì›í•´ìš”.",
          statusBuildError: "ìƒì„± ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆì–´ìš”.",
          errorImageCreate: "ì´ë¯¸ì§€ ìƒì„±ì— ì‹¤íŒ¨í–ˆì–´ìš”.",
          errorZipModule: "ZIP ëª¨ë“ˆ ë¡œë“œ ì‹¤íŒ¨",
          btnDelete: "ì‚­ì œ",
          htmlNotFound: "HTML íŒŒì¼ì„ ì°¾ì„ ìˆ˜ ì—†ì–´ìš”.",
          htmlReading: "HTML íŒŒì¼ ì½ëŠ” ì¤‘...",
          htmlConvertingImages: "ì´ë¯¸ì§€ ê²½ë¡œ ë³€í™˜ ì¤‘...",
          htmlLoaded: "HTML íŒŒì¼ ë¡œë“œ ì™„ë£Œ!",
          htmlReadFail: "HTML íŒŒì¼ì„ ì½ì„ ìˆ˜ ì—†ì–´ìš”: {message}",
          htmlNeedUpload: "ë¨¼ì € HTML íŒŒì¼ì„ ì—…ë¡œë“œí•´ì£¼ì„¸ìš”.",
          htmlLibMissing: "PDF ë³€í™˜ ë¼ì´ë¸ŒëŸ¬ë¦¬ë¥¼ ë¶ˆëŸ¬ì˜¬ ìˆ˜ ì—†ì–´ìš”.",
          htmlLoadingImages: "ì´ë¯¸ì§€ ë¡œë”© ì¤‘...",
          htmlConverting:
            "PDF ë³€í™˜ ì¤‘... (í˜ì´ì§€ê°€ ê¸¸ë©´ ì‹œê°„ì´ ê±¸ë¦´ ìˆ˜ ìˆì–´ìš”)",
          htmlPdfDone: "PDF ë‹¤ìš´ë¡œë“œ ì™„ë£Œ!",
          htmlPdfFail: "PDF ë³€í™˜ ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆì–´ìš”: {message}",
          htmlPreviewEmptyHtml:
            "ğŸ“„ HTML íŒŒì¼ì„ ì—…ë¡œë“œí•˜ë©´ ì—¬ê¸°ì— ë¯¸ë¦¬ë³´ê¸°ê°€ í‘œì‹œë©ë‹ˆë‹¤.",
          htmlFileNameWithImages: "{name} (ì´ë¯¸ì§€ {count}ê°œ í¬í•¨)",
          unknownError: "ì•Œ ìˆ˜ ì—†ëŠ” ì˜¤ë¥˜",
        },
        en: {
          metaTitle: "Image Merge & PDF â€” Free Web Tool",
          metaDescription:
            "Combine multiple images into one (PNG/JPG/WEBP) or convert to PDF and download. Drag sorting, margins, spacing, and layout supported.",
          metaOgTitle: "Image Merge & PDF â€” Free Web Tool",
          metaOgDescription:
            "Merge multiple images into one and download as PDF instantly.",
          heroTitle: "Image Merge & PDF",
          heroSubtitle:
            "Upload â†’ drag reorder â†’ merge into one image or save as PDF",
          viewOtherServices: "See other services â†—",
          htmlTitle: "HTML â†’ PDF",
          htmlSubtitle:
            "Upload an HTML file and convert it to PDF for download.",
          htmlDropTitle: "Drag & drop HTML file",
          htmlDropHint: "Select the HTML file with its images together.",
          htmlFileAria: "Select HTML and image files",
          btnSelectFiles: "Select files",
          htmlUploadedTitle: "Uploaded HTML",
          btnClear: "Clear",
          htmlViewportTitle: "PDF rendering width",
          htmlViewportHint: "Pick PC/mobile width that fits the document.",
          viewportDesktop: "Desktop (1280px)",
          viewportWide: "Wide (1600px)",
          viewportAuto: "Auto from document",
          viewportMobile: "Mobile (390px)",
          viewportCustom: "Custom",
          viewportCustomLabel: "Custom input (px)",
          btnConvertHtml: "Convert to PDF",
          previewTitle: "Preview",
          htmlPreviewEmpty: "Upload an HTML file to preview it here.",
          step1Title: "1) Add images",
          step1Subtitle:
            "Supports PNG/JPG/WEBP/GIF (first frame) and other browser-readable images.",
          btnClearAll: "Clear all",
          dropzoneTitle: "Drag & drop here",
          dropzoneHint: "Or click the file select button.",
          imageFileAria: "Select image files",
          btnSelectImages: "Select files",
          dragTip:
            "ğŸ’¡ Tip: Drag the thumbnails in the list to change order.",
          uploadListTitle: "Upload list",
          unitImages: " files",
          emptyHint:
            "ğŸ“· No images yet.<br />Upload above or click the file select button.",
          step2Title: "2) Output settings",
          step2Subtitle:
            "Merge into one image (vertical/horizontal/grid) or export as PDF (per page/grid).",
          outputTypeLabel: "Output type",
          outTypeImage: "Download merged image",
          outTypePdf: "Download as PDF",
          outTypeZip: "Convert ZIP (image formats only)",
          zipHint: "ZIP converts each image to the chosen format and bundles it.",
          imageFormatLabel: "Image format",
          qualityLabel: "JPG/WEBP quality",
          layoutTitle: "Merge layout",
          layoutHint: "Applies when output type is â€œmerged imageâ€",
          layoutNote: "Canvas-based",
          layoutVertical: "Vertical",
          layoutHorizontal: "Horizontal",
          layoutGrid: "Grid",
          keepSizeTitle: "Keep original sizes",
          keepSizeHint: "Merge with zero gap and no resizing",
          gapLabel: "Gap (px)",
          bgLabel: "Background",
          bgDark: "Dark",
          bgLight: "White",
          bgTransparent: "Transparent (PNG only)",
          gridColsLabel: "Grid columns",
          bgTip:
            "ğŸ’¡ Transparent background only works with <span class=\"text-white font-semibold\">PNG</span>.",
          pdfTitle: "PDF settings",
          pdfHint: "Applies when output type is PDF",
          pdfNote: "Per page",
          pdfPaperLabel: "Paper",
          pdfPaperAuto: "Fit to image (recommended)",
          pdfOrientationLabel: "Orientation",
          orientationPortrait: "Portrait",
          orientationLandscape: "Landscape",
          orientationAuto: "Auto",
          pdfMarginLabel: "Margin (px)",
          pdfOnePerPage: "One image per page",
          pdfGrid: "Grid on one page",
          pdfTip:
            "ğŸ’¡ â€œFit to imageâ€ sizes the PDF page to minimize <span class=\"text-white font-semibold\">cropping</span>.",
          btnPreview: "Preview",
          btnMakeDownload: "Build download",
          step3Title: "3) Result preview",
          step3Subtitle:
            "Merged images show on the canvas; PDFs show page count/size info.",
          btnTop: "Top",
          canvasTip:
            "âš¡ Large images can be slow depending on browser performance.",
          infoTitle: "Info",
          infoTotal: "Total images",
          infoSize: "Estimated size",
          infoPages: "PDF pages",
          infoState: "State",
          stateIdle: "Idle",
          privacyNote:
            "ğŸ”’ This page processes everything <b class=\"text-white\">in your browser</b>.<br />(Large/high-res files can be slow.)",
          footerNote: "Â© FunnyFunny Cloud â€” fast, lightweight experimental web",
          statusLoading: "Loading",
          statusPreview: "Preview",
          statusError: "Error",
          statusBuilding: "Building",
          errorImageRead: "Unable to read the image.",
          errorOnlyImages: "Only image files are supported.",
          statusLoadingImages: "Loading {count} images...",
          statusUploadDone: "Upload complete!",
          statusPreviewError:
            "Preview error. Please re-check your settings.",
          statusNeedImages: "Please add images first.",
          statusBuildingNow: "Building... (large images may take a while)",
          statusMergedDone: "Merged image downloaded!",
          statusPdfDone: "PDF downloaded!",
          statusZipDone: "ZIP downloaded!",
          statusZipUnsupported:
            "ZIP is supported only for PNG/JPG/WEBP output.",
          statusBuildError: "An error occurred during build.",
          errorImageCreate: "Failed to generate image.",
          errorZipModule: "Failed to load ZIP module",
          btnDelete: "Delete",
          htmlNotFound: "Could not find an HTML file.",
          htmlReading: "Reading HTML file...",
          htmlConvertingImages: "Converting image paths...",
          htmlLoaded: "HTML loaded!",
          htmlReadFail: "Failed to read HTML file: {message}",
          htmlNeedUpload: "Upload an HTML file first.",
          htmlLibMissing: "PDF libraries are not available.",
          htmlLoadingImages: "Loading images...",
          htmlConverting: "Converting to PDF... (long pages may take time)",
          htmlPdfDone: "PDF downloaded!",
          htmlPdfFail: "PDF conversion failed: {message}",
          htmlPreviewEmptyHtml:
            "ğŸ“„ Upload an HTML file to preview it here.",
          htmlFileNameWithImages: "{name} (includes {count} images)",
          unknownError: "Unknown error",
        },
      };

      let currentLang = "ko";

      function t(key, vars = {}) {
        const table = translations[currentLang] || translations.ko;
        const template = table[key] ?? translations.ko[key] ?? key;
        return template.replace(/\{(\w+)\}/g, (_, token) =>
          vars[token] !== undefined ? vars[token] : `{${token}}`
        );
      }

      function applyTranslations() {
        document.title = t("metaTitle");
        const desc = document.querySelector('meta[name="description"]');
        if (desc) desc.setAttribute("content", t("metaDescription"));
        const ogTitle = document.querySelector('meta[property="og:title"]');
        if (ogTitle) ogTitle.setAttribute("content", t("metaOgTitle"));
        const ogDesc = document.querySelector(
          'meta[property="og:description"]'
        );
        if (ogDesc) ogDesc.setAttribute("content", t("metaOgDescription"));

        document.querySelectorAll("[data-i18n]").forEach((el) => {
          el.textContent = t(el.dataset.i18n);
        });
        document.querySelectorAll("[data-i18n-html]").forEach((el) => {
          el.innerHTML = t(el.dataset.i18nHtml);
        });
        document.querySelectorAll("[data-i18n-aria]").forEach((el) => {
          el.setAttribute("aria-label", t(el.dataset.i18nAria));
        });
      }

      function setLang(lang, options = {}) {
        const nextLang = translations[lang] ? lang : "ko";
        currentLang = nextLang;
        document.documentElement.lang = nextLang;
        localStorage.setItem("preferredLang", nextLang);
        document.querySelectorAll(".lang-switch button").forEach((button) => {
          button.classList.toggle("active", button.dataset.lang === nextLang);
        });
        applyTranslations();
        renderList();

        if (options.updateUrl) {
          const url = new URL(window.location.href);
          url.searchParams.set("lang", nextLang);
          window.history.replaceState({}, "", url);
        }
      }

      function detectLang() {
        const params = new URLSearchParams(window.location.search);
        const paramLang = params.get("lang");
        if (translations[paramLang]) return paramLang;
        const stored = localStorage.getItem("preferredLang");
        if (translations[stored]) return stored;
        const browser = navigator.language?.toLowerCase() || "";
        return browser.startsWith("en") ? "en" : "ko";
      }

      document.querySelectorAll(".lang-switch button").forEach((button) => {
        button.addEventListener("click", () => {
          setLang(button.dataset.lang, { updateUrl: true });
        });
      });

      setLang(detectLang(), { updateUrl: false });

      const $ = (id) => document.getElementById(id);

      const fileInput = $("fileInput");
      const dropzone = $("dropzone");
      const listEl = $("list");
      const emptyHint = $("emptyHint");
      const countEl = $("count");
      const statusEl = $("status");

      const outTypeEl = $("outType");
      const imgFormatEl = $("imgFormat");
      const qualityEl = $("quality");
      const qLabelEl = $("qLabel");
      const qualityWrap = $("qualityWrap");

      const gapEl = $("gap");
      const bgEl = $("bg");
      const colsEl = $("cols");
      const keepSizeEl = $("keepSize");

      const pdfSizeEl = $("pdfSize");
      const pdfOriEl = $("pdfOri");
      const pdfMarginEl = $("pdfMargin");

      const infoCountEl = $("infoCount");
      const infoSizeEl = $("infoSize");
      const infoPagesEl = $("infoPages");
      const infoStateEl = $("infoState");

      const canvas = $("canvas");
      const ctx = canvas.getContext("2d");

      /** @type {{id:string, name:string, file:File|null, src:string, img:HTMLImageElement, w:number, h:number}[]} */
      let items = [];

      function setStatus(msg, good = false) {
        statusEl.innerHTML = msg ? (good ? `âœ… ${msg}` : `â„¹ï¸ ${msg}`) : "";
      }

      function fmtBytes(bytes) {
        if (!Number.isFinite(bytes) || bytes <= 0) return "-";
        const units = ["B", "KB", "MB", "GB"];
        let i = 0,
          v = bytes;
        while (v >= 1024 && i < units.length - 1) {
          v /= 1024;
          i++;
        }
        return `${v.toFixed(i === 0 ? 0 : 2)} ${units[i]}`;
      }

      function updateQualityUI() {
        const mime = imgFormatEl.value;
        const show = mime === "image/jpeg" || mime === "image/webp";
        qualityWrap.style.display = show ? "block" : "none";
        qLabelEl.textContent = Number(qualityEl.value).toFixed(2);
      }
      qualityEl.addEventListener("input", updateQualityUI);
      imgFormatEl.addEventListener("change", () => {
        updateQualityUI();
        syncBgForTransparency();
      });

      function syncBgForTransparency() {
        // transparent only makes sense for PNG
        if (bgEl.value === "transparent" && imgFormatEl.value !== "image/png") {
          bgEl.value = "#0b1220";
        }
        if (imgFormatEl.value !== "image/png") {
          // keep option but warn via status
          if (bgEl.value === "transparent") bgEl.value = "#0b1220";
        }
      }
      bgEl.addEventListener("change", syncBgForTransparency);

      function syncGapForKeepSize() {
        if (keepSizeEl.checked) {
          gapEl.value = "0";
          gapEl.disabled = true;
        } else {
          gapEl.disabled = false;
        }
      }
      keepSizeEl.addEventListener("change", () => {
        syncGapForKeepSize();
        preview();
      });

      function uid() {
        return Math.random().toString(16).slice(2) + Date.now().toString(16);
      }

      async function fileToImage(file) {
        const src = URL.createObjectURL(file);
        const img = new Image();
        img.decoding = "async";
        img.loading = "eager";
        await new Promise((res, rej) => {
          img.onload = () => res();
          img.onerror = () => rej(new Error(t("errorImageRead")));
          img.src = src;
        });
        return { src, img, w: img.naturalWidth, h: img.naturalHeight };
      }

      async function addFiles(files) {
        const arr = [...files].filter(
          (f) => f && f.type && f.type.startsWith("image/")
        );
        if (!arr.length) {
          setStatus(t("errorOnlyImages"));
          return;
        }

        setStatus(t("statusLoadingImages", { count: arr.length }));
        infoStateEl.textContent = t("statusLoading");

        for (const f of arr) {
          try {
            const { src, img, w, h } = await fileToImage(f);
            items.push({
              id: uid(),
              name: f.name || "image",
              file: f,
              src,
              img,
              w,
              h,
            });
          } catch (e) {
            console.warn(e);
          }
        }
        renderList();
        await preview(); // auto preview
        setStatus(t("statusUploadDone"), true);
        infoStateEl.textContent = t("stateIdle");
      }

      function cleanup() {
        for (const it of items) {
          try {
            if (it.src?.startsWith("blob:")) URL.revokeObjectURL(it.src);
          } catch {}
        }
        items = [];
        renderList();
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        canvas.width = 1;
        canvas.height = 1;
        setStatus("");
        infoPagesEl.textContent = "-";
        infoSizeEl.textContent = "-";
        infoStateEl.textContent = t("stateIdle");
      }

      function renderList() {
        listEl.innerHTML = "";
        countEl.textContent = String(items.length);
        infoCountEl.textContent = String(items.length);

        emptyHint.style.display = items.length ? "none" : "block";

        for (const it of items) {
          const card = document.createElement("div");
          card.className =
            "rounded-2xl border border-white/10 bg-white/5 p-3 flex gap-3 items-center";
          card.dataset.id = it.id;

          const thumb = document.createElement("img");
          thumb.src = it.src;
          thumb.alt = "thumb";
          thumb.className =
            "w-20 h-16 object-cover rounded-xl border border-white/10 bg-black/30";

          const meta = document.createElement("div");
          meta.className = "min-w-0 flex-1";
          meta.innerHTML = `
          <div class="font-semibold truncate">${escapeHtml(it.name)}</div>
          <div class="muted small">${it.w}Ã—${it.h}</div>
        `;

          const btns = document.createElement("div");
          btns.className = "flex gap-2";
          const del = document.createElement("button");
          del.className = "btn btn-ghost btn-sm";
          del.type = "button";
          del.textContent = t("btnDelete");
          del.onclick = () => {
            items = items.filter((x) => x.id !== it.id);
            try {
              if (it.src?.startsWith("blob:")) URL.revokeObjectURL(it.src);
            } catch {}
            renderList();
            preview();
          };

          btns.appendChild(del);

          card.appendChild(thumb);
          card.appendChild(meta);
          card.appendChild(btns);

          listEl.appendChild(card);
        }
      }

      function escapeHtml(s) {
        return String(s).replace(
          /[&<>"']/g,
          (m) =>
            ({
              "&": "&amp;",
              "<": "&lt;",
              ">": "&gt;",
              '"': "&quot;",
              "'": "&#039;",
            }[m])
        );
      }

      // Drag reorder
      new Sortable(listEl, {
        animation: 160,
        ghostClass: "opacity-40",
        onEnd: () => {
          const order = [...listEl.querySelectorAll("[data-id]")].map(
            (el) => el.dataset.id
          );
          items.sort((a, b) => order.indexOf(a.id) - order.indexOf(b.id));
          preview();
        },
      });

      // Dropzone events
      ["dragenter", "dragover"].forEach((ev) =>
        dropzone.addEventListener(ev, (e) => {
          e.preventDefault();
          dropzone.classList.add("drop-active");
        })
      );
      ["dragleave", "drop"].forEach((ev) =>
        dropzone.addEventListener(ev, (e) => {
          e.preventDefault();
          dropzone.classList.remove("drop-active");
        })
      );
      dropzone.addEventListener("drop", (e) => addFiles(e.dataTransfer.files));

      fileInput.addEventListener("change", (e) => addFiles(e.target.files));
      $("btnClear").addEventListener("click", cleanup);

      function getLayout() {
        return (
          document.querySelector('input[name="layout"]:checked')?.value ||
          "vertical"
        );
      }
      function getPdfMode() {
        return (
          document.querySelector('input[name="pdfMode"]:checked')?.value ||
          "one"
        );
      }

      function bgColor() {
        return bgEl.value === "transparent" ? null : bgEl.value;
      }

      function clampInt(v, def, min, max) {
        const n = Math.floor(Number(v));
        if (!Number.isFinite(n)) return def;
        return Math.max(min, Math.min(max, n));
      }

      async function preview() {
        try {
          if (!items.length) {
            infoSizeEl.textContent = "-";
            infoPagesEl.textContent = "-";
            infoStateEl.textContent = t("stateIdle");
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            return;
          }

          infoStateEl.textContent = t("statusPreview");
          const outType = outTypeEl.value;

          if (outType === "pdf") {
            // For PDF, we don't render all pages; show page count expectation.
            const mode = getPdfMode();
            infoPagesEl.textContent =
              mode === "one" ? String(items.length) : "1";
            // Show rough size as sum of original file sizes (very rough)
            const approx = items.reduce((a, it) => a + (it.file?.size || 0), 0);
            infoSizeEl.textContent = `~${fmtBytes(approx)}`;
            infoStateEl.textContent = t("stateIdle");
            // still show a merged preview canvas (first few) for UX
          } else {
            infoPagesEl.textContent = "-";
          }

          // Always draw a merged canvas preview (based on current layout)
          const layout = getLayout();
          const keepSize = keepSizeEl.checked;
          const gap = keepSize ? 0 : Math.max(0, Number(gapEl.value) || 0);
          const cols = clampInt(colsEl.value, 2, 1, 8);

          // Scale preview to keep it reasonable
          const PREVIEW_MAX = 2200; // px
          const {
            w: cw,
            h: ch,
            placements,
          } = computeLayout(items, layout, gap, cols, keepSize);

          const scale = Math.min(1, PREVIEW_MAX / Math.max(cw, ch));
          canvas.width = Math.max(1, Math.floor(cw * scale));
          canvas.height = Math.max(1, Math.floor(ch * scale));

          // background
          ctx.clearRect(0, 0, canvas.width, canvas.height);
          const bg = bgColor();
          if (bg) {
            ctx.fillStyle = bg;
            ctx.fillRect(0, 0, canvas.width, canvas.height);
          }

          // draw
          for (const p of placements) {
            const dx = Math.floor(p.x * scale);
            const dy = Math.floor(p.y * scale);
            const dw = Math.floor(p.w * scale);
            const dh = Math.floor(p.h * scale);
            ctx.drawImage(p.img, dx, dy, dw, dh);
          }

          // size estimate by encoding preview (approx)
          try {
            const mime = outType === "image" ? imgFormatEl.value : "image/png";
            const q = Number(qualityEl.value) || 0.9;
            const dataUrl = canvas.toDataURL(mime, q);
            const bytes = Math.floor(
              ((dataUrl.length - dataUrl.indexOf(",") - 1) * 3) / 4
            );
            infoSizeEl.textContent =
              fmtBytes(bytes) + (outType === "pdf" ? " (preview)" : "");
          } catch {
            infoSizeEl.textContent = "-";
          }
          infoStateEl.textContent = t("stateIdle");
        } catch (e) {
          console.error(e);
          setStatus(t("statusPreviewError"));
          infoStateEl.textContent = t("statusError");
        }
      }

      function computeLayout(items, layout, gap, cols, keepSize = false) {
        // Strategy:
        // - vertical/horizontal: normalize widths/heights to a common edge to look consistent.
        // - grid: each cell size = max cell width among images normalized by aspect (simple).
        const imgs = items.map((it) => ({
          img: it.img,
          w: it.w,
          h: it.h,
          a: it.w / it.h,
        }));

        if (layout === "horizontal") {
          if (keepSize) {
            let x = 0;
            let maxH = 0;
            const placements = imgs.map((xi) => {
              const p = { img: xi.img, x, y: 0, w: xi.w, h: xi.h };
              x += xi.w + gap;
              maxH = Math.max(maxH, xi.h);
              return p;
            });
            const W = Math.max(1, x - gap);
            const H = Math.max(1, maxH);
            return { w: W, h: H, placements };
          }
          // common height
          const H = median(imgs.map((x) => x.h));
          let x = 0;
          const placements = imgs.map((xi) => {
            const w = Math.round(H * xi.a);
            const p = { img: xi.img, x, y: 0, w, h: H };
            x += w + gap;
            return p;
          });
          const W = Math.max(1, x - gap);
          return { w: W, h: H, placements };
        }

        if (layout === "grid") {
          const C = Math.max(1, cols);
          // choose a target cell width from median widths
          const cellW = Math.max(240, Math.round(median(imgs.map((x) => x.w))));
          const cellH = Math.max(180, Math.round(cellW * 0.75));
          const placements = [];
          let maxX = 0,
            maxY = 0;

          imgs.forEach((xi, i) => {
            const r = Math.floor(i / C);
            const c = i % C;
            const x = c * (cellW + gap);
            const y = r * (cellH + gap);

            // fit image into cell preserving aspect (contain)
            const scale = Math.min(cellW / xi.w, cellH / xi.h);
            const w = Math.round(xi.w * scale);
            const h = Math.round(xi.h * scale);
            const ox = x + Math.round((cellW - w) / 2);
            const oy = y + Math.round((cellH - h) / 2);

            placements.push({ img: xi.img, x: ox, y: oy, w, h });

            maxX = Math.max(maxX, x + cellW);
            maxY = Math.max(maxY, y + cellH);
          });

          const W = maxX;
          const H = maxY;
          return { w: W, h: H, placements };
        }

        // vertical default: common width
        if (keepSize) {
          let y = 0;
          let maxW = 0;
          const placements = imgs.map((xi) => {
            const p = { img: xi.img, x: 0, y, w: xi.w, h: xi.h };
            y += xi.h + gap;
            maxW = Math.max(maxW, xi.w);
            return p;
          });
          const H = Math.max(1, y - gap);
          const W = Math.max(1, maxW);
          return { w: W, h: H, placements };
        }
        const W = median(imgs.map((x) => x.w));
        let y = 0;
        const placements = imgs.map((xi) => {
          const h = Math.round(W / xi.a);
          const p = { img: xi.img, x: 0, y, w: W, h };
          y += h + gap;
          return p;
        });
        const H = Math.max(1, y - gap);
        return { w: W, h: H, placements };
      }

      function median(arr) {
        const a = [...arr]
          .filter((n) => Number.isFinite(n))
          .sort((x, y) => x - y);
        if (!a.length) return 800;
        const mid = Math.floor(a.length / 2);
        return a.length % 2 ? a[mid] : Math.round((a[mid - 1] + a[mid]) / 2);
      }

      // Build outputs
      async function buildMergedImageBlob() {
        if (!items.length) throw new Error(t("statusNeedImages"));

        const layout = getLayout();
        const keepSize = keepSizeEl.checked;
        const gap = keepSize ? 0 : Math.max(0, Number(gapEl.value) || 0);
        const cols = clampInt(colsEl.value, 2, 1, 8);

        const { w, h, placements } = computeLayout(
          items,
          layout,
          gap,
          cols,
          keepSize
        );

        // Use offscreen canvas for full-res output
        const off = document.createElement("canvas");
        off.width = Math.max(1, Math.floor(w));
        off.height = Math.max(1, Math.floor(h));
        const c = off.getContext("2d");

        const bg = bgColor();
        if (bg) {
          c.fillStyle = bg;
          c.fillRect(0, 0, off.width, off.height);
        } else {
          c.clearRect(0, 0, off.width, off.height);
        }

        for (const p of placements) {
          c.drawImage(p.img, p.x, p.y, p.w, p.h);
        }

        const mime = imgFormatEl.value;
        const q = Number(qualityEl.value) || 0.9;

        // transparency only meaningful for png
        const blob = await new Promise((res) => off.toBlob(res, mime, q));
        if (!blob) throw new Error(t("errorImageCreate"));
        return blob;
      }

      async function buildPdfBlob() {
        if (!items.length) throw new Error(t("statusNeedImages"));
        const { jsPDF } = window.jspdf;

        const mode = getPdfMode();
        const sizeOpt = pdfSizeEl.value;
        const marginPx = Math.max(0, Number(pdfMarginEl.value) || 0);

        // helper: px->pt (rough). We'll keep consistent by using px as unit directly with jsPDF "px".
        // jsPDF supports unit: 'px' (with hotfix). We'll use px to simplify.
        const unit = "px";

        // Determine orientation per page if auto
        const oriOpt = pdfOriEl.value;

        let doc = null;
        let pages = 0;

        if (mode === "grid") {
          // One page grid using current grid settings
          const gap = Math.max(0, Number(gapEl.value) || 0);
          const cols = clampInt(colsEl.value, 2, 1, 8);
          const { w, h, placements } = computeLayout(items, "grid", gap, cols);

          // Page size
          const pageW = sizeOpt === "auto" ? w + marginPx * 2 : undefined;
          const pageH = sizeOpt === "auto" ? h + marginPx * 2 : undefined;

          const orientation = resolveOrientation(oriOpt, w, h);
          doc = new jsPDF({
            unit,
            format: sizeOpt === "auto" ? [pageW, pageH] : sizeOpt,
            orientation,
          });

          // background (optional)
          // We'll draw images onto a canvas first for speed, then add as one image
          const off = document.createElement("canvas");
          off.width = Math.max(1, Math.floor(w));
          off.height = Math.max(1, Math.floor(h));
          const c = off.getContext("2d");
          c.fillStyle = "#ffffff";
          c.fillRect(0, 0, off.width, off.height);
          for (const p of placements) c.drawImage(p.img, p.x, p.y, p.w, p.h);

          const imgData = off.toDataURL("image/jpeg", 0.92);
          doc.addImage(imgData, "JPEG", marginPx, marginPx, w, h);
          pages = 1;
        } else {
          // One per page
          for (let i = 0; i < items.length; i++) {
            const it = items[i];
            const w = it.w,
              h = it.h;

            const orientation = resolveOrientation(oriOpt, w, h);

            if (!doc) {
              const format =
                sizeOpt === "auto"
                  ? [w + marginPx * 2, h + marginPx * 2]
                  : sizeOpt;
              doc = new jsPDF({ unit, format, orientation });
            } else {
              const format =
                sizeOpt === "auto"
                  ? [w + marginPx * 2, h + marginPx * 2]
                  : sizeOpt;
              doc.addPage(format, orientation);
            }

            // fit image into page area (contain)
            const page = doc.internal.pageSize;
            const pageW = page.getWidth();
            const pageH = page.getHeight();

            const maxW = pageW - marginPx * 2;
            const maxH = pageH - marginPx * 2;

            const scale = Math.min(maxW / w, maxH / h);
            const dw = w * scale;
            const dh = h * scale;
            const x = marginPx + (maxW - dw) / 2;
            const y = marginPx + (maxH - dh) / 2;

            // encode per image (jpeg for speed; png is big)
            const dataUrl = imageToDataURL(it.img, "image/jpeg", 0.92);
            doc.addImage(dataUrl, "JPEG", x, y, dw, dh);
            pages++;
          }
        }

        infoPagesEl.textContent = String(pages);

        const blob = doc.output("blob");
        return blob;
      }

      function resolveOrientation(opt, w, h) {
        if (opt === "auto") return w >= h ? "landscape" : "portrait";
        return opt;
      }

      function imageToDataURL(img, mime, quality) {
        const c = document.createElement("canvas");
        c.width = img.naturalWidth || img.width;
        c.height = img.naturalHeight || img.height;
        const x = c.getContext("2d");
        x.fillStyle = "#ffffff";
        x.fillRect(0, 0, c.width, c.height);
        x.drawImage(img, 0, 0);
        return c.toDataURL(mime, quality);
      }

      function downloadBlob(blob, filename) {
        const a = document.createElement("a");
        const url = URL.createObjectURL(blob);
        a.href = url;
        a.download = filename;
        document.body.appendChild(a);
        a.click();
        a.remove();
        setTimeout(() => URL.revokeObjectURL(url), 1500);
      }

      async function buildZipOfConvertedImages() {
        if (!items.length) throw new Error(t("statusNeedImages"));
        if (!window.JSZip) throw new Error(t("errorZipModule"));

        const zip = new JSZip();
        const mime = imgFormatEl.value;
        const q = Number(qualityEl.value) || 0.9;

        for (let i = 0; i < items.length; i++) {
          const it = items[i];
          const dataUrl = imageToDataURL(it.img, mime, q);
          const base64 = dataUrl.split(",")[1];
          const ext =
            mime === "image/png"
              ? "png"
              : mime === "image/webp"
              ? "webp"
              : "jpg";
          const safe = (it.name || `image-${i + 1}`)
            .replace(/[^\w.-]+/g, "_")
            .replace(/\.+$/, "");
          zip.file(`${String(i + 1).padStart(2, "0")}_${safe}.${ext}`, base64, {
            base64: true,
          });
        }

        const blob = await zip.generateAsync({ type: "blob" });
        return blob;
      }

      $("btnPreview").addEventListener("click", preview);

      $("btnMake").addEventListener("click", async () => {
        try {
          if (!items.length) {
            setStatus(t("statusNeedImages"));
            return;
          }
          infoStateEl.textContent = t("statusBuilding");
          setStatus(t("statusBuildingNow"));

          const outType = outTypeEl.value;

          if (outType === "image") {
            const blob = await buildMergedImageBlob();
            const ext =
              imgFormatEl.value === "image/png"
                ? "png"
                : imgFormatEl.value === "image/webp"
                ? "webp"
                : "jpg";
            downloadBlob(blob, `merged.${ext}`);
            setStatus(t("statusMergedDone"), true);
          } else if (outType === "pdf") {
            const blob = await buildPdfBlob();
            downloadBlob(blob, "images.pdf");
            setStatus(t("statusPdfDone"), true);
          } else if (outType === "zip") {
            if (
              imgFormatEl.value === "image/png" ||
              imgFormatEl.value === "image/jpeg" ||
              imgFormatEl.value === "image/webp"
            ) {
              const blob = await buildZipOfConvertedImages();
              downloadBlob(blob, "converted_images.zip");
              setStatus(t("statusZipDone"), true);
            } else {
              setStatus(t("statusZipUnsupported"));
            }
          }

          await preview();
        } catch (e) {
          console.error(e);
          setStatus(e?.message || t("statusBuildError"));
        } finally {
          infoStateEl.textContent = t("stateIdle");
        }
      });

      // If output type changes, adjust preview info
      outTypeEl.addEventListener("change", () => {
        const t = outTypeEl.value;
        // If zip selected, merged layout still used for preview; ok
        preview();
      });

      // live preview on setting changes (lightweight ones)
      [gapEl, colsEl, bgEl, pdfSizeEl, pdfOriEl, pdfMarginEl].forEach((el) => {
        el.addEventListener("input", () => preview());
        el.addEventListener("change", () => preview());
      });
      document
        .querySelectorAll('input[name="layout"]')
        .forEach((r) => r.addEventListener("change", preview));
      document
        .querySelectorAll('input[name="pdfMode"]')
        .forEach((r) => r.addEventListener("change", preview));



      // HTML file to PDF conversion
      let uploadedHtmlContent = null;
      let uploadedHtmlFileName = null;
      let htmlIframe = null;
      let captureIframe = null;
      let uploadedImageFiles = new Map(); // íŒŒì¼ëª… -> File ê°ì²´

      const htmlFileInput = $("htmlFileInput");
      const htmlDropzone = $("htmlDropzone");
      const htmlPreview = $("htmlPreview");
      const htmlFileName = $("htmlFileName");
      const btnClearHtml = $("btnClearHtml");
      const btnConvertHtmlToPdf = $("btnConvertHtmlToPdf");
      const htmlStatus = $("htmlStatus");
      const htmlViewportEl = $("htmlViewport");
      const htmlCustomWrap = $("htmlCustomWrap");
      const htmlCustomWidthEl = $("htmlCustomWidth");

      function setHtmlStatus(msg, good = false) {
        htmlStatus.innerHTML = msg ? (good ? `âœ… ${msg}` : `â„¹ï¸ ${msg}`) : "";
      }

      function getHtmlViewportWidth() {
        const mode = htmlViewportEl.value;
        if (mode === "desktop") return 1280;
        if (mode === "wide") return 1600;
        if (mode === "mobile") return 390;
        if (mode === "custom") {
          const v = parseInt(htmlCustomWidthEl.value, 10);
          return Number.isFinite(v) && v >= 320 ? Math.min(v, 3840) : 1280;
        }
        return null;
      }

      function getHtmlViewportWidthForCapture() {
        const mode = htmlViewportEl.value;
        if (mode === "auto") {
          const previewWidth = htmlPreview?.clientWidth || 0;
          return Math.max(previewWidth, 1280);
        }
        return getHtmlViewportWidth();
      }

      function applyHtmlPreviewViewport() {
        if (!htmlIframe) return;
        const width = getHtmlViewportWidth();
        if (width) {
          htmlIframe.style.width = width + "px";
          htmlIframe.style.margin = "0 auto";
        } else {
          htmlIframe.style.width = "100%";
          htmlIframe.style.margin = "0";
        }
      }

      function syncHtmlViewportUI() {
        const mode = htmlViewportEl.value;
        htmlCustomWrap.style.display = mode === "custom" ? "block" : "none";
        applyHtmlPreviewViewport();
      }

      // íŒŒì¼ì„ base64 data URLë¡œ ë³€í™˜
      function fileToDataURL(file) {
        return new Promise((resolve, reject) => {
          const reader = new FileReader();
          reader.onload = () => resolve(reader.result);
          reader.onerror = reject;
          reader.readAsDataURL(file);
        });
      }

      // HTML ë‚´ë¶€ì˜ ì´ë¯¸ì§€ ê²½ë¡œë¥¼ base64ë¡œ ë³€í™˜
      async function convertImagePathsToBase64(htmlText, imageFiles) {
        // HTMLì„ íŒŒì‹±í•˜ê¸° ìœ„í•œ ì„ì‹œ DOM
        const parser = new DOMParser();
        const doc = parser.parseFromString(htmlText, "text/html");

        // ëª¨ë“  img íƒœê·¸ ì°¾ê¸°
        const images = doc.querySelectorAll("img");
        let modified = false;

        for (const img of images) {
          const src = img.getAttribute("src");
          if (!src) continue;

          // ì´ë¯¸ base64ë‚˜ data URLì¸ ê²½ìš° ìŠ¤í‚µ
          if (src.startsWith("data:") || src.startsWith("blob:")) continue;

          // ì ˆëŒ€ URLì¸ ê²½ìš°ë„ ìŠ¤í‚µ (ì™¸ë¶€ ì´ë¯¸ì§€)
          if (src.startsWith("http://") || src.startsWith("https://")) continue;

          // íŒŒì¼ëª… ì¶”ì¶œ (ê²½ë¡œì—ì„œ ë§ˆì§€ë§‰ ë¶€ë¶„ë§Œ)
          const fileName = src.split("/").pop().split("\\").pop();

          // ì´ë¯¸ì§€ íŒŒì¼ ì°¾ê¸°
          let imageFile = null;

          // ì •í™•í•œ íŒŒì¼ëª… ë§¤ì¹­
          if (imageFiles.has(fileName)) {
            imageFile = imageFiles.get(fileName);
          } else {
            // ëŒ€ì†Œë¬¸ì ë¬´ì‹œ ë§¤ì¹­
            for (const [name, file] of imageFiles.entries()) {
              if (name.toLowerCase() === fileName.toLowerCase()) {
                imageFile = file;
                break;
              }
            }
          }

          if (imageFile) {
            try {
              const dataURL = await fileToDataURL(imageFile);
              img.setAttribute("src", dataURL);
              modified = true;
            } catch (e) {
              console.warn(`ì´ë¯¸ì§€ ë³€í™˜ ì‹¤íŒ¨: ${fileName}`, e);
            }
          } else {
            console.warn(`ì´ë¯¸ì§€ íŒŒì¼ì„ ì°¾ì„ ìˆ˜ ì—†ìŒ: ${fileName}`);
          }
        }

        if (modified) {
          return doc.documentElement.outerHTML;
        }
        return htmlText;
      }

      async function loadHtmlFile(files) {
        try {
          // ì—¬ëŸ¬ íŒŒì¼ ì¤‘ HTML íŒŒì¼ ì°¾ê¸°
          const fileArray =
            files instanceof FileList ? Array.from(files) : [files];
          const htmlFile = fileArray.find((f) =>
            f.name.match(/\.(html|htm)$/i)
          );

          if (!htmlFile) {
            setHtmlStatus(t("htmlNotFound"));
            return;
          }

          // ì´ë¯¸ì§€ íŒŒì¼ë“¤ ì €ì¥
          uploadedImageFiles.clear();
          fileArray.forEach((file) => {
            if (file !== htmlFile && file.type.startsWith("image/")) {
              // íŒŒì¼ëª…ì„ í‚¤ë¡œ ì‚¬ìš© (ëŒ€ì†Œë¬¸ì êµ¬ë¶„)
              uploadedImageFiles.set(file.name, file);
            }
          });

          setHtmlStatus(t("htmlReading"));
          let htmlText = await htmlFile.text();

          // ì´ë¯¸ì§€ ê²½ë¡œë¥¼ base64ë¡œ ë³€í™˜
          if (uploadedImageFiles.size > 0) {
            setHtmlStatus(t("htmlConvertingImages"));
            htmlText = await convertImagePathsToBase64(
              htmlText,
              uploadedImageFiles
            );
          }

          uploadedHtmlContent = htmlText;
          uploadedHtmlFileName = htmlFile.name;

          // ë¯¸ë¦¬ë³´ê¸° iframe ìƒì„±
          if (htmlIframe) {
            htmlIframe.remove();
          }
          htmlIframe = document.createElement("iframe");
          htmlIframe.style.width = "100%";
          htmlIframe.style.minHeight = "400px";
          htmlIframe.style.border = "none";
          htmlIframe.style.borderRadius = "8px";
          htmlIframe.style.backgroundColor = "#ffffff";
          htmlPreview.style.overflow = "auto";
          htmlPreview.style.maxHeight = "600px";
          htmlPreview.innerHTML = "";
          htmlPreview.appendChild(htmlIframe);

          // iframeì— HTML ë‚´ìš© ì“°ê¸°
          htmlIframe.onload = () => {
            const iframeDoc =
              htmlIframe.contentDocument || htmlIframe.contentWindow.document;
            const iframeWindow = htmlIframe.contentWindow;

            // ì‹¤ì œ ì½˜í…ì¸  í¬ê¸°ì— ë§ì¶° iframe í¬ê¸° ì¡°ì •
            setTimeout(() => {
              try {
                const contentHeight = Math.max(
                  iframeDoc.body?.scrollHeight || iframeDoc.documentElement?.scrollHeight || 400,
                  iframeDoc.body?.offsetHeight || 400
                );
                
                // ìµœëŒ€ ë†’ì´ ì œí•œ (600px ì»¨í…Œì´ë„ˆì— ë§ì¶¤)
                htmlIframe.style.height = Math.min(contentHeight, 800) + "px";
              } catch (e) {
                console.warn("iframe í¬ê¸° ì¡°ì • ì‹¤íŒ¨:", e);
                htmlIframe.style.height = "400px";
              }

              setHtmlStatus(t("htmlLoaded"), true);
              btnConvertHtmlToPdf.disabled = false;
            }, 200);
          };

          htmlIframe.srcdoc = htmlText;
          applyHtmlPreviewViewport();
          const imageCount = uploadedImageFiles.size;
          htmlFileName.textContent =
            imageCount > 0
              ? t("htmlFileNameWithImages", {
                  name: htmlFile.name,
                  count: imageCount,
                })
              : htmlFile.name;
          btnClearHtml.style.display = "block";
        } catch (e) {
          console.error(e);
          setHtmlStatus(t("htmlReadFail", { message: e.message }));
        }
      }

      function clearHtmlFile() {
        uploadedHtmlContent = null;
        uploadedHtmlFileName = null;
        uploadedImageFiles.clear();
        if (htmlIframe) {
          htmlIframe.remove();
          htmlIframe = null;
        }
        htmlPreview.innerHTML = `<div class="muted small text-center py-8">${t(
          "htmlPreviewEmptyHtml"
        )}</div>`;
        htmlFileName.textContent = "";
        btnClearHtml.style.display = "none";
        btnConvertHtmlToPdf.disabled = true;
        setHtmlStatus("");
      }

      // ëª¨ë“  ì´ë¯¸ì§€ê°€ ë¡œë“œë  ë•Œê¹Œì§€ ê¸°ë‹¤ë¦¬ëŠ” í•¨ìˆ˜
      function waitForImages(doc) {
        return new Promise((resolve) => {
          const images = doc.querySelectorAll("img");
          if (images.length === 0) {
            resolve();
            return;
          }

          let loaded = 0;
          let hasError = false;

          const checkComplete = () => {
            loaded++;
            if (loaded === images.length) {
              // ëª¨ë“  ì´ë¯¸ì§€ ë¡œë“œ ì™„ë£Œ í›„ ì•½ê°„ì˜ ì¶”ê°€ ëŒ€ê¸° (ë Œë”ë§ ì™„ë£Œ ë³´ì¥)
              setTimeout(resolve, 300);
            }
          };

          images.forEach((img) => {
            if (img.complete && img.naturalHeight !== 0) {
              // ì´ë¯¸ ë¡œë“œëœ ì´ë¯¸ì§€
              checkComplete();
            } else {
              // ë¡œë”© ì¤‘ì¸ ì´ë¯¸ì§€
              img.onload = checkComplete;
              img.onerror = () => {
                hasError = true;
                checkComplete(); // ì—ëŸ¬ê°€ ë‚˜ë„ ê³„ì† ì§„í–‰
              };
              // ì´ë¯¸ ë¡œë“œëœ ê²½ìš°ë¥¼ ëŒ€ë¹„í•´ ë‹¤ì‹œ í™•ì¸
              if (img.complete) {
                checkComplete();
              }
            }
          });
        });
      }

      async function convertHtmlFileToPdf() {
        try {
          if (!uploadedHtmlContent || !htmlIframe) {
            setHtmlStatus(t("htmlNeedUpload"));
            return;
          }

          if (!window.html2canvas || !window.jspdf) {
            setHtmlStatus(t("htmlLibMissing"));
            return;
          }

          setHtmlStatus(t("htmlLoadingImages"));
          btnConvertHtmlToPdf.disabled = true;

          // ìº¡ì²˜ìš© iframe ì¤€ë¹„ (PC í­ ê¸°ë³¸)
          const captureWidth = getHtmlViewportWidthForCapture() || 1280;
          if (!captureIframe) {
            captureIframe = document.createElement("iframe");
            captureIframe.style.position = "absolute";
            captureIframe.style.left = "-99999px";
            captureIframe.style.top = "0";
            captureIframe.style.border = "0";
            captureIframe.style.visibility = "hidden";
            captureIframe.style.pointerEvents = "none";
            captureIframe.style.backgroundColor = "#ffffff";
            document.body.appendChild(captureIframe);
          }
          captureIframe.style.width = captureWidth + "px";
          captureIframe.style.height = "1px";

          const captureReady = new Promise((resolve) => {
            captureIframe.onload = resolve;
          });
          captureIframe.srcdoc = uploadedHtmlContent;
          await captureReady;

          const iframeDoc =
            captureIframe.contentDocument || captureIframe.contentWindow.document;
          const iframeBody = iframeDoc.body;
          const iframeWindow = captureIframe.contentWindow;

          // ëª¨ë“  ì´ë¯¸ì§€ê°€ ë¡œë“œë  ë•Œê¹Œì§€ ëŒ€ê¸°
          await waitForImages(iframeDoc);

          // ì¶”ê°€ ë Œë”ë§ ëŒ€ê¸° ì‹œê°„
          await new Promise((resolve) => setTimeout(resolve, 500));

          setHtmlStatus(t("htmlConverting"));

          // ì‹¤ì œ ë·°í¬íŠ¸ í¬ê¸° ê°€ì ¸ì˜¤ê¸° (iframe ë‚´ë¶€ì˜ ì‹¤ì œ ë Œë”ë§ í¬ê¸°)
          const contentWidth = Math.max(
            iframeBody.scrollWidth || iframeBody.offsetWidth || 1920,
            iframeDoc.documentElement?.scrollWidth || 0,
            iframeWindow.innerWidth || 1920
          );
          const contentHeight = Math.max(
            iframeBody.scrollHeight || iframeBody.offsetHeight || 1080,
            iframeDoc.documentElement?.scrollHeight || 0,
            iframeWindow.innerHeight || 1080
          );

          // html2canvasë¡œ iframe ë‚´ìš©ì„ ìº”ë²„ìŠ¤ë¡œ ë³€í™˜ (ê³ í•´ìƒë„ë¡œ ì„ ëª…í•˜ê²Œ)
          const scale = 2; // ê³ í•´ìƒë„ë¡œ ì„ ëª…í•˜ê²Œ
          const canvas = await html2canvas(iframeBody, {
            scale: scale, // ê³ í•´ìƒë„ë¡œ ì„ ëª…í•˜ê²Œ
            useCORS: true,
            allowTaint: true, // trueë¡œ ë³€ê²½í•˜ì—¬ ëª¨ë“  ì´ë¯¸ì§€ í¬í•¨ (ë³´ì•ˆ ê²½ê³  ë¬´ì‹œ)
            logging: false,
            backgroundColor: "#ffffff",
            width: contentWidth,
            height: contentHeight,
            windowWidth: contentWidth,
            windowHeight: contentHeight,
            x: 0,
            y: 0,
            removeContainer: false,
            imageTimeout: 30000, // íƒ€ì„ì•„ì›ƒ ì¦ê°€ (30ì´ˆ)
            foreignObjectRendering: false, // ì™¸ë¶€ ê°ì²´ ë Œë”ë§ ë¹„í™œì„±í™” (í˜¸í™˜ì„±)
            onclone: (clonedDoc) => {
              // í´ë¡ ëœ ë¬¸ì„œì—ì„œ ìŠ¤íƒ€ì¼ ë³´ì • (ë²„íŠ¼ì´ í‹€ì–´ì§€ì§€ ì•Šë„ë¡)
              const clonedBody = clonedDoc.body;
              if (clonedBody) {
                clonedBody.style.transform = "none";
                clonedBody.style.transformOrigin = "top left";
                // ëª¨ë“  ìš”ì†Œì˜ transform ì œê±° (ë²„íŠ¼ ë“±ì´ ì •í™•í•˜ê²Œ ë Œë”ë§ë˜ë„ë¡)
                const allElements = clonedBody.querySelectorAll("*");
                allElements.forEach((el) => {
                  if (el.style && el.style.transform) {
                    el.style.transform = "none";
                  }
                });

                // í´ë¡ ëœ ë¬¸ì„œì˜ ëª¨ë“  ì´ë¯¸ì§€ë„ ë¡œë“œ ëŒ€ê¸°
                const clonedImages = clonedDoc.querySelectorAll("img");
                clonedImages.forEach((img) => {
                  // base64 ì´ë¯¸ì§€ë‚˜ data URL ì´ë¯¸ì§€ ì²˜ë¦¬
                  if (img.src && img.src.startsWith("data:")) {
                    // data URLì€ ì´ë¯¸ ë¡œë“œëœ ê²ƒìœ¼ë¡œ ê°„ì£¼
                    return;
                  }
                  // ì™¸ë¶€ ì´ë¯¸ì§€ì˜ ê²½ìš° ì›ë³¸ src ìœ ì§€
                  if (img.src && !img.complete) {
                    // ì´ë¯¸ì§€ê°€ ì•„ì§ ë¡œë“œë˜ì§€ ì•Šì€ ê²½ìš° ì›ë³¸ ë¬¸ì„œì—ì„œ ê°€ì ¸ì˜¤ê¸°
                    const originalImg = iframeDoc.querySelector(
                      `img[src="${img.src}"]`
                    );
                    if (originalImg && originalImg.complete) {
                      img.src = originalImg.src;
                    }
                  }
                });
              }
            },
          });

          const imgData = canvas.toDataURL("image/png", 1.0);
          const { jsPDF } = window.jspdf;

          // PDF ìƒì„± - í”½ì…€ì„ mmë¡œ ë³€í™˜ (96 DPI ê¸°ì¤€: 1px = 0.264583mm)
          // scaleì„ ê³ ë ¤í•˜ì—¬ ì‹¤ì œ í¬ê¸° ê³„ì‚°
          const pxToMm = 0.264583;
          const actualWidth = canvas.width / scale;
          const actualHeight = canvas.height / scale;
          const pdfWidth = actualWidth * pxToMm;
          const pdfHeight = actualHeight * pxToMm;

          // ë°©í–¥ì„ ì •í™•í•˜ê²Œ ê²°ì • (ê°€ë¡œ/ì„¸ë¡œ ë¹„ìœ¨ ê¸°ì¤€)
          const isLandscape = actualWidth > actualHeight;

          const pdf = new jsPDF({
            orientation: isLandscape ? "landscape" : "portrait",
            unit: "mm",
            format: [pdfWidth, pdfHeight],
            compress: true,
          });

          // ì´ë¯¸ì§€ë¥¼ PDFì— ì¶”ê°€ (ì •í™•í•œ í¬ê¸°ì™€ ë°©í–¥ ìœ ì§€)
          pdf.addImage(
            imgData,
            "PNG",
            0,
            0,
            pdfWidth,
            pdfHeight,
            undefined,
            "FAST"
          );

          // íŒŒì¼ëª… ìƒì„±
          const pdfFileName =
            uploadedHtmlFileName.replace(/\.(html|htm)$/i, "") + ".pdf";

          // PDF ë‹¤ìš´ë¡œë“œ
          pdf.save(pdfFileName);
          setHtmlStatus(t("htmlPdfDone"), true);
          btnConvertHtmlToPdf.disabled = false;
        } catch (e) {
          console.error(e);
          setHtmlStatus(
            t("htmlPdfFail", { message: e?.message || t("unknownError") })
          );
          btnConvertHtmlToPdf.disabled = false;
        }
      }

      // HTML file upload events
      ["dragenter", "dragover"].forEach((ev) =>
        htmlDropzone.addEventListener(ev, (e) => {
          e.preventDefault();
          htmlDropzone.classList.add("drop-active");
        })
      );
      ["dragleave", "drop"].forEach((ev) =>
        htmlDropzone.addEventListener(ev, (e) => {
          e.preventDefault();
          htmlDropzone.classList.remove("drop-active");
        })
      );
      htmlDropzone.addEventListener("drop", (e) => {
        const files = e.dataTransfer.files;
        if (files.length > 0) {
          loadHtmlFile(files);
        }
      });

      htmlFileInput.addEventListener("change", (e) => {
        if (e.target.files.length > 0) {
          loadHtmlFile(e.target.files);
        }
      });

      btnClearHtml.addEventListener("click", clearHtmlFile);
      btnConvertHtmlToPdf.addEventListener("click", convertHtmlFileToPdf);
      htmlViewportEl.addEventListener("change", syncHtmlViewportUI);
      htmlCustomWidthEl.addEventListener("input", applyHtmlPreviewViewport);

      // init
      updateQualityUI();
      syncGapForKeepSize();
      preview();
      syncHtmlViewportUI();
    </script>
  
<ins class="adsbygoogle"
     style="display:block; text-align:center"
     data-ad-client="ca-pub-1204894220949193"
     data-ad-slot="5145068706"
     data-ad-format="auto"
     data-full-width-responsive="true"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
    
</body>
</html>
